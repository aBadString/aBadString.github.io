<h1 id="组件化框架" align="center">组件化框架</h1>
<!-- @import "[TOC]" {cmd="toc"} -->

<!-- code_chunk_output -->

- [1. Node](#1-node)
  - [1.1. 安装并换源](#11-安装并换源)
  - [1.2. 安装 yarn 和 UMI](#12-安装-yarn-和-umi)
  - [1.3. Hello Node](#13-hello-node)
- [2. React](#2-react)
  - [2.1. React COP: 面向组件编程](#21-react-cop-面向组件编程)
    - [2.1.1. Hello React](#211-hello-react)
    - [2.1.2. JSX 语法](#212-jsx-语法)
      - [2.1.2.1. 什么是 JSX?](#2121-什么是-jsx)
      - [2.1.2.2. JSX 中嵌入表达式](#2122-jsx-中嵌入表达式)
      - [2.1.2.3. JSX 本质](#2123-jsx-本质)
      - [2.1.2.4. JSX 语法规则](#2124-jsx-语法规则)
    - [2.1.3. 元素（虚拟 DOM）渲染](#213-元素虚拟-dom渲染)
      - [2.1.3.1. 虚拟 DOM 与 DOM diff 算法](#2131-虚拟-dom-与-dom-diff-算法)
      - [2.1.3.2. 计时器的例子](#2132-计时器的例子)
    - [2.1.4. 组件及其三大属性](#214-组件及其三大属性)
      - [2.1.4.1. 创建组件的两种方式](#2141-创建组件的两种方式)
      - [2.1.4.2. 组件的3大属性: 组件参数 props](#2142-组件的3大属性-组件参数-props)
      - [2.1.4.3. 组件的3大属性: 组件状态 state](#2143-组件的3大属性-组件状态-state)
      - [2.1.4.4. 组件的3大属性: refs](#2144-组件的3大属性-refs)
    - [2.1.5. 组件的生命周期](#215-组件的生命周期)
    - [2.1.6. 事件处理](#216-事件处理)
    - [2.1.7. 条件渲染](#217-条件渲染)
    - [2.1.8. 列表](#218-列表)
      - [2.1.8.1. key 的作用与效率问题](#2181-key-的作用与效率问题)
    - [2.1.9. 表单](#219-表单)
      - [2.1.9.1. 非受控组件](#2191-非受控组件)
      - [2.1.9.2. 受控组件](#2192-受控组件)
    - [2.1.10. create-react-app](#2110-create-react-app)
      - [2.1.10.1. 创建 React 应用](#21101-创建-react-应用)
      - [2.1.10.2. React 应用的目录结构与文件](#21102-react-应用的目录结构与文件)
  - [2.2. React Ajax: axios](#22-react-ajax-axios)
    - [2.2.1. axios 安装与使用](#221-axios-安装与使用)
    - [2.2.2. 配置代理（解决跨域问题）](#222-配置代理解决跨域问题)
      - [2.2.2.1. 方法一](#2221-方法一)
      - [2.2.2.2. 方法二](#2222-方法二)
    - [2.2.3. Fetch](#223-fetch)
    - [2.2.4. PubSubJS 消息发布订阅](#224-pubsubjs-消息发布订阅)
  - [2.3. React Router: SPA](#23-react-router-spa)
    - [2.3.1. SPA 单页面多组件](#231-spa-单页面多组件)
    - [2.3.2. 基本路由组件](#232-基本路由组件)
    - [2.3.3. Link 与 NavLink](#233-link-与-navlink)
    - [2.3.4. 路由匹配规则（Switch、Route 的 exact 属性、Redirect）](#234-路由匹配规则switch-route-的-exact-属性-redirect)
    - [2.3.5. 路由组件与一般组件（history 对象、withRouter 函数）](#235-路由组件与一般组件history-对象-withrouter-函数)
    - [2.3.6. 向路由组件传递参数](#236-向路由组件传递参数)
    - [2.3.7. 两种 Router：BrowserRouter、HashRouter](#237-两种-routerbrowserrouter-hashrouter)
  - [2.4. React UI: Ant Design](#24-react-ui-ant-design)
    - [2.4.1. 安装使用](#241-安装使用)
    - [2.4.2. 配置](#242-配置)
- [3. Vue](#3-vue)
  - [3.1. Hello Vue](#31-hello-vue)
  - [3.2. 单向绑定与双向绑定](#32-单向绑定与双向绑定)
  - [3.3. 事件绑定](#33-事件绑定)
  - [3.4. 条件渲染](#34-条件渲染)
  - [3.5. 循环](#35-循环)
  - [3.6. created 和网络请求](#36-created-和网络请求)

<!-- /code_chunk_output -->

# 1. Node

> Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行时。

> npm是名声最广的前端包管理器，为Node.js自带
> cnpm是npm的阿里版，用的是阿里的源
> yarn的出现是想取代npm包管理工具，特点是快速安全可靠
> tyarn这个是yarn的阿里版，用的是阿里的源


## 1.1. 安装并换源

将下载的 zip 解压，并配置好环境变量即可。
```shell
# 淘宝npm镜像
npm config set registry https://registry.npm.taobao.org

# 查看当前源
> npm config get registry
https://registry.npm.taobao.org/
```

## 1.2. 安装 yarn 和 UMI
```shell
#查看其版本号
> node -v
v14.13.1
# 安装 yarn，其中 tyarn 使用的是 npm.taobao.org 的源，速度要快一些
# 可以把 yarn 看做了优化了的npm
# -g 是指全局安装
npm i yarn tyarn -g

# 进行测试，如果能够正常输出版本信息则说明安装成功了
tyarn -v

# 下面开始安装umi
tyarn global add umi
# 测试
umi
```

- 安装失败，记得用管理员身份安装。
- PowerShell 无法运行 .ps1 脚本的问题：
  原因是 PS 的执行策略为 Restricted。
  `get-executionpolicy` 用于查看当前执行策略。`set-executionpolicy RemoteSigned` 改一下执行策略即可。如果不想改，用 .cmd 后缀的脚本也可以。
  > https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies
- umi 找不到命令。环境变量问题，执行 `yarn global bin`；将输出结果 `C:\Users\aBadString\AppData\Local\Yarn\bin` 添加到环境变量。

> yarn的安装和使用 https://www.cnblogs.com/mumusen/p/9760732.html

## 1.3. Hello Node

1. **编写一个 js 文件**
```js
// 引入依赖：Node.js 的 http 模块
const http = require('http');

const server = http.createServer(
  (req, res) => {
    res.statusCode = 200;
    res.setHeader('Content-Type', 'text/plain');
    res.end('hello, node\n');
  }
);

const hostname = '127.0.0.1';
const port = 3000;
server.listen(
  port,
  hostname,
  () => {
    console.log(`server run in http://${hostname}:${port}/`);
  }
);
```

2. **运行 JS**
```shell
node ./src/01node.HelloNode.js
```

3. **浏览器访问 http://127.0.0.1:3000/**
hello, node


# 2. React

一个用于动态构建用户界面的 JavaScript 库

React的特点
- Declarative (声明式编码)
- Component-Based (组件化编码)
- Learn Once, Write Anywhere (一次学习，随处编写。支持客户端与服务器渲染)
- 高效
- 单向数据流

## 2.1. React COP: 面向组件编程

### 2.1.1. Hello React

```html
<!DOCTYPE html>
<html lang="cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello React</title>
    <!-- 导入两个 React 的库文件: react.js, react-dom.js -->
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <!-- Babel 可以转换新版本的 ES 语法和 JSX 语法 -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="me"></div>
    <!-- 在 babel 的脚本标签中可以写 JSX 语法 -->
    <script type="text/babel">
        ReactDOM.render(
            <h1>hello, react</h1>,
            document.getElementById('me')
        );
    </script>
</body>
</html>
```

### 2.1.2. JSX 语法

#### 2.1.2.1. 什么是 JSX?

- 全称: JavaScript XML
- react 定义的一种类似于 XML 的JS扩展语法: XML + JS
- 作用: 用来创建 react 虚拟 DOM(元素)对象

下面是一个简单的赋值语句：
```js
const element = <h1>Hello, world!</h1>;
```
但是表达式的右边好像并不是一个 JS 正常的对象，而更像一个 HTML 标签，为什么可以在 JS 代码中写 HTML 标签呢？
其实这就是 React 的 JSX 语法。像这样的表达式将通过 Babel 将其转化为一个 JS 对象（Babel 是 JavaScript 编译器，可以转换新版本的 ES 语法和 JSX 语法）。

在浏览器的控制台中调试 element 对象：
```js
typeof element
"object"

element.$$typeof
Symbol(react.element)

element.type
"h1"

element.props
{children: "Hello, world!"}
```

可以发现 element 对象表示了 一个 HTML 标签，也就是表示了一个真实的 DOM 对象。所有我们把 element 对象称为 **虚拟 DOM** 对象。

在 JSX 语法中，赋值好右边的表达式中只能有一个根标签，但是根标签内部可以嵌套其他标签。

```js
// 这是错误的写法：只能有一个根标签
const element = <h1>Hello, world!</h1><h1>Hello, world!</h1>;
// 根标签内部可以嵌套其他标签
const element = <h1><p>Hello, world!</p> <p>hahaha</p></h1>;
// 支持多行
const element = (
    <h1>
        <p>Hello, world!</p> 
        <p>hahaha</p>
    </h1>
);
```

#### 2.1.2.2. JSX 中嵌入表达式

在 JSX 语法中，可以在大括号内放置任何有效的 JavaScript **表达式**
```js
<script type="text/babel">
    var a = 1;
    var b = 20;
    var baidu = {
        url: "https://www.baidu.com",
        name: "百度"
    };
    const element =
        <h1>
            <p>hello, react</p>
            <p>{a} + {b} = {a+b}</p>
            <a href={baidu.url}>{baidu.name}</a>
        </h1>;

    ReactDOM.render(
        element,
        document.getElementById('me')
    );
</script>
```

注意区分：**JS 语句(代码)**与**JS 表达式**
1. 表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方
```js
a
a+b
demo(1)
arr.map() 
function test () {}
```
2. 语句(代码)
```js
if(){}
for(){}
switch(){case:xxxx}
```

#### 2.1.2.3. JSX 本质

Babel 会把 JSX 转译成一个名为 React.createElement() 函数调用。
以下两种示例代码完全等效（后者无需依赖 Babel）：
```js
<script type="text/babel">
    const element1 = (
        <h1 className="greeting">
            Hello, world!
        </h1>
    );

    ReactDOM.render(
        element1,
        document.getElementById('ele1')
    );
</script>

<script type="text/javascript">
    const element2 = React.createElement(
        'h1',
        {className: 'greeting'},
        'Hello, world!'
    );

    ReactDOM.render(
        element2,
        document.getElementById('ele2')
    );
</script>
```

React.createElement() 实际上它创建了一个这样的对象：
```js
// 注意：这是简化过的结构
const element = {
  type: 'h1',
  props: {
    className: 'greeting',
    children: 'Hello, world!'
  }
};
```

#### 2.1.2.4. JSX 语法规则

1. 定义虚拟 DOM 时，不要写引号。
2. 标签中混入 JS 表达式时要用。
3. 样式的类名指定不要用 class，要用 className。
4. 内联样式 `style={{k1: v1, k2: v2}}`。 第一对花括号表示插入表达式； 第二对花括号表示 JSON 对象。
5. 只有一个根标签。
6. 标签必须闭合
7. 标签首字母。
    - 若小写字母开头，则将改标签转为 HTML 中同名元素；若 HTML 中无该标签对应的同名元素，则报错。
    - 若大写字母开头，react就去渲染对应的组件，若组件没有定义，则报错。


### 2.1.3. 元素（虚拟 DOM）渲染

> 元素是构成 React 应用的最小砖块。
> 元素描述了你在屏幕上想看到的内容。

**React高效的原因:**
- 虚拟(virtual)DOM, 不总是直接操作DOM(批量更新, 减少更新的次数) 
- 高效的DOM Diff算法, 最小化页面重绘(减小页面更新的区域)


#### 2.1.3.1. 虚拟 DOM 与 DOM diff 算法

1. **虚拟DOM是什么?**
- 一个虚拟DOM(元素)是一个一般的js对象, 准确的说是一个对象树
- 虚拟DOM保存了真实DOM的层次关系和一些基本属性，与真实DOM一一对应
- 如果只是更新虚拟DOM, 页面是不会重绘的
- 虚拟 DOM 对象比较轻，DOM 对象比较重

2. **Virtual DOM 算法的基本步骤**
- 用JS对象树表示DOM树的结构；然后用这个树构建一个真正的DOM树插到文档当中
- 当状态变更的时候，重新构造一棵新的对象树。然后用新的树和旧的树进行比较，记录两棵树差异
- 把差异应用到真实DOM树上，视图就更新了

3. **进一步理解**
- Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。
- 既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。JS只操作Virtual DOM，经 DOM diff 比较后，再把变更写入 DOM。


#### 2.1.3.2. 计时器的例子

React 虚拟 DOM 元素是不可变对象。一旦被创建，你就无法更改它的子元素或者属性。更新 UI 唯一的方式是创建一个全新的虚拟 DOM 元素，并将其传入。
```js
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Clock</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        function tick() {
            const element = (
                <div>
                    <h1>Hello, world!</h1>
                    <h2>It is {new Date().toLocaleTimeString()}.</h2>
                </div>
            );
            ReactDOM.render(element, document.getElementById('root'));
        }

        setInterval(tick, 1000);
    </script>
</body>
</html>
```
从浏览器控制台可以看出，React 只更新它需要更新的部分。虽然我们每次都会新建一个描述整个 UI 树的元素，但是React DOM 只会更新实际改变了的内容。
![](../images/React/DOM-Diff.png)

### 2.1.4. 组件及其三大属性

#### 2.1.4.1. 创建组件的两种方式

1. 无状态函数 (简单组件, 推荐使用)
```js
function Welcome(props) {
  return <h1>Hello, {props.name}</h1>;
}
```
2. ES6类语法 (复杂组件, 推荐使用)
```js
class Welcome extends React.Component {
  render() {
    return <h1>Hello, {this.props.name}</h1>;
  }
}
```

React 虚拟 DOM 可以是 DOM 标签 `const element = <h1>Hello, world!</h1>;`。
React 虚拟 DOM 还可以是用户自定义的组件 `const element = <Welcome name="Sara" />;`

以下是组件的基本使用的代码：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Component</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // 定义 Welcome 组件
        function Welcome(props) {
            return <h1>Hello, {props.name}</h1>;
        }

        // 创建 Welcome 组件的一个 虚拟 DOM 对象
        const element = <Welcome name="Sara" />;
        // 渲染 element 对象到 root div 中
        ReactDOM.render(
            element,
            document.getElementById('root')
        );
    </script>
</body>
</html>
```
当然，组件也可以嵌套：
```js
// 定义组件 App
function App(props) {
    return (
        <div>
            <p>{props.children}</p>
            <Welcome name="Sara" />
            <Welcome name="Cahal" />
            <Welcome name="Edite" />
        </div>
    );
}
// 渲染 App 组件的一个对象到 root2 div 中
ReactDOM.render(
    <App>koko</App>,
    document.getElementById('root2')
);
```

#### 2.1.4.2. 组件的3大属性: 组件参数 props
- props 是组件标签的所有属性的集合
- 作用: 从外部向组件内部传递数据
- 在组件内部读取属性: `props.属性名`(function)或者`this.props.属性名`(class)
- 在组件内部读取标签之间的内容： `props.children`(function)或者`this.props.children`(class)
- **props 具有只读性。所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。**

#### 2.1.4.3. 组件的3大属性: 组件状态 state
- state 是私有的，并且完全受控于当前组件
- 组件被称为"状态机", 页面的显示是根据组件的 state 属性的数据来显示

1. 初始化指定
```js
constructor() {
  super();
  this.state = {
    k1 : v1,
    k2 : v2
  };
}
```
2. 获取 state
```js
this.state.属性名
```
3. 更新 state，会导致更新界面
```js
this.setState(
  {
    newK : newV
  }
);
```

在前文中为了更新页面，我们需要调用 `ReactDOM.render` 来将一个新的虚拟 DOM 对象填入(渲染)到相应的 DOM 中去。
这种页面更新方式完全是主动的更新，而组件可以在 state 属性被修改后自动的更新页面。

使用 state 属性达到自动更新页面：
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>State</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        class Clock extends React.Component {
            // 类的构造器
            constructor(props) {
                super(props);
                // 给 state 赋初值
                this.state = {date: new Date()}
            }
            // 页面渲染
            render() {
                return (
                    <div>
                        <h1>Hello, world!</h1>
                        <h2>It is {this.state.date.toLocaleTimeString()}.</h2>
                    </div>
                );
            }
            // 页面渲染后执行
            componentDidMount() {
                // 设置计时器
                this.timerID = setInterval(
                    () => this.tick(),
                    1000
                );
            }
            // 组件将要被移除之前执行
            componentWillUnmount() {
                // 清除计时器
                clearInterval(this.timerID);
            }
            // 计时器事件
            tick() {
                // 修改 this.state 的值
                this.setState(
                  {
                    date: new Date()
                  }
                );
            }
        }

        ReactDOM.render(
            <Clock />,
            document.getElementById('root')
        );
    </script>
</body>
</html>
```

**React 方言：批量传递 props**
`...todo`：批量传递props (React 方言)
大括号 `{}` 表示嵌入 JS 表达式 `...todo`
```jsx
<TodoItem key={todo.id} {...todo} />
// 等价于
<TodoItem key={todo.id} id={todo.id} name={todo.name} done={todo.done} />
```
==注意：==  
- JS 中没有对象展开运算符 `...a`； JS 没有这种写法，是错误的语法。
- 而这种 `let b = {...a}` 是字面量形式复制一个对象，即(深)拷贝对象；


#### 2.1.4.4. 组件的3大属性: refs
- refs 是组件内包含 ref 属性的标签元素的集合
- 作用: 找到组件内部的真实 DOM 对象, 进而操作它
- 给操作目标标签指定 ref 属性, 打一个标识
- 在组件内部获得标签对象: `this.refs.refName` (只是得到了标签元素对象)

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Refs</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
<div id="root"></div>

    <script type="text/babel">
        class MyComponent extends React.Component {
            render () {
                return (
                    <div>
                        <input type="text" ref="in" />
                        // 为了在回调中使用 `this`，这个bind是必不可少的
                        // buttonClick.bind(this)
                        //   - 根据其调用函数 buttonClick 创建一个新的函数
                        //   - 新函数的 this 被指定为 bind() 的第一个参数 this
                        <input type="button" value="同步" onClick={this.buttonClick.bind(this)}/>
                    </div>
                );
            }

            buttonClick() {
                console.log(this.refs.in.value)
            }
        }

        ReactDOM.render(
            <MyComponent />,
            document.getElementById("root")
        );
    </script>
</body>
</html>
```

### 2.1.5. 组件的生命周期

1. 组件的三个生命周期状态:
- Mount：插入真实 DOM
- Update：被重新渲染
- Unmount：被移出真实 DOM

2. 生命周期流程:
- 第一次初始化显示: `ReactDOM.render(<Xxx />, containDom)`
  1. constructor() : 构造器
  1. componentWillMount() : 将要挂载回调
  1. render() : 用于插入虚拟 DOM 回调
  1. componentDidMount() : 已经挂载回调
- 修改状态: `this.setState({})`
  1. shouldComponentUpdate() : 是否应该更新组件(若返回 false 则不往下走了)
  1. componentWillUpdate() : 将要更新回调
  1. render() : 更新(重新渲染)
  1. componentDidUpdate() : 已经更新回调
- 强制更新: `this.forceUpdate()`
  1. componentWillUpdate() : 将要更新回调
  1. render() : 更新(重新渲染)
  1. componentDidUpdate() : 已经更新回调
- 接收到新的 props 值，即父组件 render 时
  1. componentWillReceiveProps() : 接收父组件新的属性
  1. shouldComponentUpdate() : 是否应该更新组件
  1. componentWillUpdate() : 将要更新回调
  1. render() : 更新(重新渲染)
  1. componentDidUpdate() : 已经更新回调
- 卸载组件: `ReactDOM.unmountComponentAtNode(document.getElementById('root'))`
  1. componentWillUnmount() : 组件将要卸载回调

3. 常用的方法
- render(): 必须重写, 返回一个自定义的虚拟 DOM
- componentDidMount() : 在组件挂载到页面后执行一次 , 适合启动/设置一些监听
- componentWillUnmount() : 组件卸载前执行, 一般用于回收组件开启的资源

![](../images/React/React的生命周期.jpg)


### 2.1.6. 事件处理

React 事件的命名采用小驼峰式（camelCase）。

HTML 中设置按钮事件：
```html
<input type="button" value="点我" onclick="buttonClick();"/>
```
React 中设置按钮事件：
```html
<body>
<div id="root"></div>
<script type="text/babel">
    function ButtonClick() {
        function click(e) {
            console.log('按钮被点击');
        }

        return (
            <input type="button" value="点我" onClick={click}/>
        );
    }
    ReactDOM.render(<ButtonClick/>, document.getElementById("root"));
</script>
</body>
```

HTML 中阻止超链接跳转：
```html
<a href="https://www.baidu.com" onclick="return false">百度</a>
```
React 中阻止超链接跳转：
```html
<body>
<div id="root"></div>
<script type="text/babel">
    function ActionLink() {
        function handleClick(e) {
            // return false;
            e.preventDefault();
        }
        return (
            <a href="https://www.baidu.com" onClick={handleClick}>百度</a>
        );
    }
    ReactDOM.render(<ActionLink/>, document.getElementById("root"));
</script>
</body>
```

Ref 容器与事件处理
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Event</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="root"></div>
    <script type="text/babel">
        class Event extends React.Component {
            // 创建 Ref 容器
            sourceText = React.createRef();
            targetText = React.createRef();

            // 按钮点击事件
            copyText = () => {
                // console.log(this.sourceText);
                // console.log(this.targetText);
                this.targetText.current.value = this.sourceText.current.value;
            }

            render() {
                return (
                    <div>
                        <input ref={this.sourceText} />
                        <button onClick={this.copyText}>复制文本</button>
                        <input ref={this.targetText} />
                    </div>
                );
            }
        }
        ReactDOM.render(<Event/>, document.getElementById("root"));
    </script>
</body>
```

### 2.1.7. 条件渲染
- 通过 if 语句来控制组件 return 不同的虚拟 DOM。
- 阻止组件渲染：可以让 render 方法直接返回 null，而不进行任何渲染。

```html
<script type="text/babel">
    function Greeting(props) {
        if (props.ok == 'YES!') {
            return <h1>YES!</h1>;
        } else if (props.ok == 'NO!') {
            return <h1>NO!</h1>;
        } else {
            return null;
        }
    }
    function Show() {
        return (
            <div>
                <Greeting />
                <Greeting ok="YES!" />
                <Greeting ok="NO!" />
            </div>
        );
    }
    ReactDOM.render(<Show/>, document.getElementById("root"));
</script>
```

### 2.1.8. 列表

```html
<script type="text/babel">
    function NumberList(props) {
        const numbers = props.numbers;
        const lists = numbers.map(
            (number) => {
                return <li>{number}</li>;
            }
        );
        return <ul>{lists}</ul>;
    }
    ReactDOM.render(<NumberList numbers={[1,2,3,4,5,6]} />, document.getElementById("root"));
</script>
```
浏览器控制台可以看到：lists 是一个数组，数组的每一个元素都是一个虚拟 DOM 对象（$$typeof: Symbol(react.element)）
我们还可以看到浏览器给出了一个警告：Warning: Each child in a list should have a unique "key" prop. 需要给每个 li 标签加一个 key 属性：
```diff
function NumberList(props) {
    const numbers = props.numbers;
    const lists = numbers.map(
        (number) => {
-           return <li>{number}</li>;
+           return <li key={number.toString()}>{number}</li>;
        }
    );
    return <ul>{lists}</ul>;
}
```
- [**元素的 key 只有放在就近的数组上下文中才有意义。**](https://react.docschina.org/docs/lists-and-keys.html#extracting-components-with-keys)


- 因为 JSX 允许在大括号中嵌入任何有效的 JavaScript 表达式。
- 并且 JSX 也是一个表达式：在编译之后，JSX 表达式会被转为普通 JavaScript 函数调用，并且对其取值后得到 JavaScript 对象。
- 所有我们可以得到下面这种奇奇怪怪的写法：`JS ( JSX { JS ( JSX ) } )`

可以内联 map() 返回的结果：
```js
function NumberList(props) {
    const numbers = props.numbers;
    return ( // JS 语法
        <ul> <!-- JSX 语法 -->
            { // JS 语法
                numbers.map(
                    (number) => {
                        return (
                            <!-- JSX 语法 -->
                            <li key={number.toString()}>
                                {number}
                            </li>
                        );
                    }
                )
            }
        </ul>
    );
}
```

#### 2.1.8.1. key 的作用与效率问题

经典面试题:
1. React / Vue 中的 key 有什么作用？（key的内部原理是什么？）
2. 为什么遍历列表时，key 最好不要用 index？
3. 开发中如何选择 key？

答：
1. 虚拟 DOM 中 key 的作用：
    - 简单的说: key 是虚拟 DOM 对象的标识, 在更新页面时起着极其重要的作用。
    - 详细的说: 当 state 发生变化时，React 会根据新的 state 生成新的虚拟 DOM。随后 React 将新虚拟 DOM 与旧虚拟 DOM 进行 diff 比较：
        ```java
        if (新旧虚拟 DOM 存在相同的 key) {
            if (新旧虚拟 DOM 的内容相同) {
                复用旧的真实 DOM;
                // 没改真实 DOM, 高效
            } else {
                根据新的虚拟 DOM 生成新的真实 DOM;
                用新的真实 DOM 替换旧的真实 DOM;
                // 改了真实 DOM
            }
        } else {
            根据虚拟 DOM 生成真实 DOM;
            将真实 DOM 渲染到到页面;
            // 添加新的真实 DOM
        }
        ```

2. 用 数据下标 index 作为 key 可能会引发的问题：
    1. 若原数据的排序发生了变化（逆序添加、逆序删除等）：会导致无必要的真实 DOM 的更新， 降低页面渲染效率。
    2. 如果列表标签中包含输入类 DOM 子标签（input 等）：会导致子标签错位。

3. key 的选择：
    1. 最好使用每条数据的唯一标识作为 key, 比如 id 这样的唯一值。
    2. 还可以取数据的哈希值作为 key。
    2. 如果确定只是简单的展示数据，不涉及数据的更新，用 index 也是可以的。

### 2.1.9. 表单

#### 2.1.9.1. 非受控组件
即原来普通的表单，需要提交表单时才获取数据
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>非受控组件</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
<div id="root"></div>

<script type="text/babel">

    class Login extends React.Component {

        username = React.createRef();
        password = React.createRef();

        // 表单提交事件
        submit = (event) => {
            // 传入的是事件对象
            // event.target 是触发事件的对象
            console.log(event.target);
            // <form>用户名：<input name="username" type="text">密码：<input name="password" type="password"><button>登录</button></form>

            // 阻止表单提交
            event.preventDefault();

            // 通过 ajax 提交表单（模拟）
            console.log(`用户名${this.username.current.value}\t密码${this.password.current.value}`);
        }

        render() {
            return (
                <form onSubmit={this.submit}>
                    用户名：<input ref={this.username} name="username" type="text" />
                    密码：<input ref={this.password} name="password" type="password" />
                    <button>登录</button>
                </form>
            );
        }
    }

    ReactDOM.render(<Login />, document.getElementById("root"));
</script>
</body>
</html>
```

#### 2.1.9.2. 受控组件
曲线实现数据双向绑定
表单的状态与 state 进行绑定：当表单中输入类 DOM 的值发生改变时，触发 save 方法将值保存到 state 中
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>受控组件</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
<div id="root"></div>

<script type="text/babel">

    class Login extends React.Component {

        state = {
            username: 'admin',
            password: ''
        }

        // 当 input 的值修改时, 就将其保存到 state 中
        saveUsername = (event) => {
            // event.target 是触发事件的对象
            let username = event.target.value;
            this.setState(
                {username: username}
            );
        }
        savePassword = ( {target} ) => {
            // 通过对象的解构获取 event.target
            let password = target.value;
            this.setState(
                {password: password}
            );
        }

        // 表单提交事件
        submit = (event) => {
            // 阻止表单提交
            event.preventDefault();
            // 通过 ajax 提交表单（模拟）
            const {username, password} = this.state;
            console.log(`用户名${username}\t密码${password}`);
        }

        render() {
            return (
                <form onSubmit={this.submit}>
                    用户名：<input onChange={this.saveUsername} value={this.state.username} name="username" type="text" />
                    密码：<input onChange={this.savePassword} value={this.state.password} name="password" type="password" />
                    <button>登录</button>
                </form>
            );
        }
    }

    ReactDOM.render(<Login />, document.getElementById("root"));
</script>
</body>
</html>
```

使用函数的柯里化，进一步修改上述代码：
**函数的柯里化**：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>受控组件</title>
    <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
<div id="root"></div>

<script type="text/babel">

    class Login extends React.Component {

        state = {
            username: 'admin',
            password: ''
        }

        /* save 函数被调用时, 会返回一个函数 */
        save = (key) => {
            // 返回一个函数
            return (
                // 这个函数就是实现之前的 saveUsername、savePassword 函数的功能
                ({target}) => {
                    let value = target.value;
                    // [key] 通过变量的值给 指定对象的属性名
                    this.setState( {[key]: value} );
                }
            );
        }

        // 表单提交事件
        submit = (event) => {
            // 阻止表单提交
            event.preventDefault();
            // 通过 ajax 提交表单（模拟）
            const {username, password} = this.state;
            console.log(`用户名${username}\t密码${password}`);
        }

        render() {
            return (
                <form onSubmit={this.submit}>
                    {/* 用户名：<input onChange={this.saveUsername} value={this.state.username} name="username" type="text" /> */}
                    {/* 上面 onChange={this.saveUsername} 是把函数 saveUsername 赋值给 onChange。并没有调用函数 saveUsername */}
                    {/* 下面 onChange={this.save('username')} 是调用了函数 save，并将其返回值 赋值给 onChange */}
                    用户名：<input onChange={this.save('username')} value={this.state.username} name="username" type="text" />
                    密码：<input onChange={this.save('password')} value={this.state.password} name="password" type="password" />
                    <button>登录</button>
                </form>
            );
        }
    }

    ReactDOM.render(<Login />, document.getElementById("root"));
</script>
</body>
</html>
```


### 2.1.10. create-react-app

#### 2.1.10.1. 创建 React 应用
在上面的所有代码中，都是直接使用 script 标签来引入 React.js 库的。我们所编写的代码没有经过任何预处理，就直接响应给了浏览器。浏览器所拿到的代码版本就是我们所编写的版本。然后浏览器回去请求 react.js, react-dom.js, babel.js 来翻译 JSX 代码，此时 React 是运行在浏览器上的。
可以看出这个开发和部署过程很不**软件工程**，所以接下来我们使用 create-react-app 脚手架来创建和发布 React 应用，即进行工程化开发。

```shell
# 安装 create-react-app
# -g 表示全局安装
> npm install -g create-react-app
C:\Program Files\DevTools\node-v14.13.1-win-x64\create-react-app -> C:\Program Files\DevTools\node-v14.13.1-win-x64\node_modules\create-react-app\index.js
+ create-react-app@4.0.1
added 67 packages from 25 contributors in 2.806s

# 使用 create-react-app 创建应用 
> create-react-app my-react-app

Installing packages. This might take a couple of minutes.
Installing react, react-dom, and react-scripts with cra-template...

Initialized a git repository.

Installing template dependencies using yarnpkg...

# 整个过程主要做了以下事情：
# 1. 下载依赖包到 node_modules 中
# 2. 初始化一个 git 仓库
# 3. 安装模板依赖项

# 进入项目目录中
cd my-react-app
# 接着就是进行编码了

# 启动应用
npm start
# 或者
yarn start

# 打包应用
npm run build
# 或者
yarn build

# 下载服务器
> npm install -g serve
C:\Program Files\DevTools\node-v14.13.1-win-x64\serve -> C:\Program Files\DevTools\node-v14.13.1-win-x64\node_modules\serve\bin\serve.js
+ serve@11.3.2
added 78 packages from 39 contributors in 3.949s
# 或者
yarn global add serve

# 通过服务器运行打包项目
serve -s ./build/
```


#### 2.1.10.2. React 应用的目录结构与文件
```
my-react-app/
    |-- build          # 打包输出目录
    |-- node_modules/  # 依赖库目录
    |-- public/        # 静态资源目录
    |   |-- favicon.icon    # 网站页签图标
    |   |-- index.html      # 主页面
    |   |-- logo192.png     # logo 图片
    |   |-- logo512.png     # logo 图片
    |   |-- manifest.json   # 应用加壳的配置文件
    |   |-- robots.txt      # 爬虫协议文件
    |-- src/           # 源码目录
    |   |-- App.css             # App 组件的样式
    |   |-- App.js              # App 组件
    |   |-- App.test.js         # App 组件的单元测试
    |   |-- index.css           # 全局样式
    |   |-- index.js            # 应用入口文件
    |   |-- logo.svg            # logo 矢量图片
    |   |-- reportWebVitals.js  # 页面性能分析文件 (依赖 web-vitals)
    |   |-- setupTests.js       # 组件单元测试的文件 (依赖 jest-dom)
    |-- package.json   # 相当于 Maven 的 pom.xml
    |-- yarn.lock      # yarn 的缓存文件, 帮助 package.json 进行版本仲裁
```

package.json
```json
{
  // 应用名
  "name": "my-react-app",
  // 版本
  "version": "0.1.0",
  // 如果设置为 true, 则可以防止应用程序/软件包被意外地发布到 npm
  "private": true,
  // 作者
  "author": "aBadString",

  // 依赖列表
  // 当使用 npm install xxx 或 yarn add xxx 安装依赖时会被自动插入此列表
  "dependencies": {
    // NPM 语义版本控制规则: http://nodejs.cn/learn/semantic-versioning-using-npm
    // 以下是 react 应用的初始依赖
    // 单元测试
    "@testing-library/jest-dom": "^5.11.4",
    "@testing-library/react": "^11.1.0",
    "@testing-library/user-event": "^12.1.10",

    // 这两个是 react 核心的依赖
    "react": "^17.0.1",
    "react-dom": "^17.0.1",
    // 提供 "scripts" 配置项的命令脚本
    "react-scripts": "4.0.2",
    // 页面性能分析
    "web-vitals": "^1.0.1",

    // axios
    "axios": "^0.21.1",
    // React Router
    "react-router-dom": "^5.2.0",
    
    // Ant Design
    "antd": "^4.10.3",

    // Redux
    // react-redux 并不内置 redux, 需要单独安装
    "redux": "^4.0.5",
    "react-redux": "^7.2.2"
  },
  // 开发依赖列表
  // 只需安装在开发环境中, 而无需安装在生产环境
  // npm install --save-dev xxx 或 yarn add --dev xxx
   "devDependencies": {
    // 配合 redux 开发者工具使用
    "redux-devtools-extension": "^2.13.8",

    // react-app-rewired: React 自定义配置, 依赖 customize-cra
    "react-app-rewired": "^2.1.8",
    "customize-cra": "^1.0.0",

    // 按需加载组件代码和样式的 babel 插件
    "babel-plugin-import": "^1.13.3",

    // Less
    "less": "^4.1.1",
    "less-loader": "^8.0.0"
  }

  // 定义了一组可以运行的 node 脚本
  // 可以通过 npm run xxx 或 yarn xxx 来运行
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },

  // ESLint 配置
  // ESLint: 可组装的 JavaScript 和 JSX 检查工具
  // 像 变量未使用, a 标签的 href 未设置值 等, 会在浏览器控制台给出警告
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },

  // 用于告知要支持哪些浏览器及其版本
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    // 开发环境版本
    "development": [
      // 最近一版本 chrome 浏览器
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}
```

可以来看看脚手架生成的 public/index.html 文件的解读：
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <!-- 引入网站图标, 可能不兼容 IE
         %PUBLIC_URL% 文件夹的路径 -->
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <!-- viewport 视口, 用于不同窗口设备的网页适配 (视口与窗口的概念可参考 win32 桌面应用编程) -->
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- 指定浏览器页签、地址栏的颜色 (仅 Android 浏览器)  -->
    <meta name="theme-color" content="#000000" />
    <!-- 设置网页的描述
         搜索引擎会检索 description 和 keywords 信息，但是这两者不会影响网页的排名。 -->
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <!-- 指定网页添加到手机主屏幕后的图标 (仅 iOS) -->
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!-- 应用加壳时的配置文件 -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <title>React App</title>
  </head>
  <body>
    <!-- 浏览器不支持脚本时, 则显示以下文字 -->
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <!-- 组件容器 -->
    <div id="root"></div>
  </body>
</html>
```

应用入口文件 src/index.js
```js
// 引入 react 和 react-dom 模块
import React from 'react';
import ReactDOM from 'react-dom';
// 引入全局样式文件
import './index.css';
// 引入 App 组件
import App from './App';
// 引入页面性能分析
import reportWebVitals from './reportWebVitals';

// 将组件 App 渲染到 index.html 的 root <div> 容器中
ReactDOM.render(
  // 使用 React.StrictMode 标签包裹组件及其子组件：回去检查 React API 的调用规范
  // 会警告已弃用的 API 及其他不规范处
  <React.StrictMode>
    <App />
  </React.StrictMode>,
  document.getElementById('root')
);
// 执行页面性能分析
reportWebVitals();
```
应用根组件 src/App.js
```js
// 引入 logo 矢量图片 (Webpack 一切皆为模块)
import logo from './logo.svg';
// 引入 App 组件的样式
import './App.css';

// 定义一个函数式组件 App
function App() {
  return (
    <div className="App">
      <header className="App-header">
        <img src={logo} className="App-logo" alt="logo" />
        <p>
          Edit <code>src/App.js</code> and save to reload.
        </p>
        <a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        >
          学习 React
        </a>
      </header>
    </div>
  );
}
// 导出组件 App 作为一个模块
export default App;
```

## 2.2. React Ajax: axios

### 2.2.1. axios 安装与使用
axios 是基于 XmlHttpRequest 的，是对其的 Promise 风格封装。

创建 React App 后执行安装 `yarn add axios`

执行 GET 请求
```js
// 为给定 ID 的 user 创建请求
axios.get('/user?ID=12345')
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });

// 上面的请求也可以这样做
axios.get('/user', {
    params: {
      ID: 12345
    }
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```
执行 POST 请求
```js
axios.post('/user', {
    firstName: 'Fred',
    lastName: 'Flintstone'
  })
  .then(function (response) {
    console.log(response);
  })
  .catch(function (error) {
    console.log(error);
  });
```
执行多个并发请求
```js
function getUserAccount() {
  return axios.get('/user/12345');
}

function getUserPermissions() {
  return axios.get('/user/12345/permissions');
}

axios.all([getUserAccount(), getUserPermissions()])
  .then(axios.spread(function (acct, perms) {
    // 两个请求现在都执行完成
  }));
```

### 2.2.2. 配置代理（解决跨域问题）

先准备好一个初始的 React App，删去不必要文件：
```
.
|-- public/
|   |-- index.html
|-- src/
|   |-- App.js
|   |-- index.js
|-- package.json
```
public/index.html
```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>aBadString</title>
  </head>
  <body>
    <div id="root"></div>
  </body>
</html>
```
src/index.js
```js
import ReactDOM from 'react-dom';
import App from './App';

ReactDOM.render(<App />, document.getElementById('root'));
```
src/App.js
```js
import {Component} from 'react';
// 安装 yarn add axios
import axios from 'axios';
export default class App extends Component {
    getData = () => {
        const url = "http://localhost:5000/students";
        axios.get(url)
            .then(
                ({data}) => this.refs.me.value = data
            );
    }
    render(){
        return (
            <div>
                <button onClick={this.getData}>点击获取数据</button>
                <input ref="me" type="text" readOnly></input>
            </div>
        );
    }
}
```
注：React App 启动在 `http://127.0.0.1:3000/students`；后端服务器启动在`http://127.0.0.1:5000/students`，且没有任何跨域处理。

#### 2.2.2.1. 方法一
1. 在 package.json 中追加如下配置
```diff
{
+ "proxy": "http://127.0.0.1:5000",
  "name": "my-react-app",
// 。。。。
}
```
2. 修改 App.js 中的请求地址
使得 axios.get() 是向**当前 React App 自身**请求数据
```js
// const url = "http://localhost:3000/students"
// 这里的主机号必须和地址栏一致: 地址栏是 localhost url就得 localhost; 地址栏是 127.0.0.1 url就得 127.0.0.1
// 所有直接写 /students 补全前面主机号与当前地址栏一致
const url = "/students";
axios.get(url)
  .then(
      ({data}) => this.refs.me.value = data
  );
```
代理规则说明：
请求的 url = "/students" 会补全当前项目的 协议、域名、端口号。
即实际上 axios 是在向自身项目请求数据
- 如果当前项目中存在 url 则直接访问
  `const url = "/"; // 获取到的是 public/index.html 的内容`
- 没有，则走代理：由代理去请求 `http://127.0.0.1:5000`，代理拿到数据后，再次响应给 React App。由于代理和 React App 是一起运行在一起的所以它们同源。


说明：
1. 优点：配置简单，前端请求资源时可以不加任何前缀。
2. 缺点：不能配置多个代理。
3. 工作方式：上述方式配置代理，当请求了3000不存在的资源时，那么该请求会转发给5000 （优先匹配前端资源）

#### 2.2.2.2. 方法二
1. 创建代理配置文件src/setupProxy.js
```js
// 这个文件由 Webpack 执行, 所以不能写 ES6 语法

// 引入模块
// ES6: import
const proxy = require('http-proxy-middleware');

// 导出模块
// ES6: export 
module.exports = function(app) {
    app.use(
        // 设置代理
        proxy(
            // 需要走代理的 url 的前缀. /api1/students 走这个代理, /students 不走
            '/api1',
            {
                // 目标服务器地址
                // /api1/students 这个 url 将转发为 http://127.0.0.1:5000/api1/students
                target: 'http://127.0.0.1:5000',
                // url 重写 
                // 替换 url 中的 /api1 为 ''(空字符串)
                // 最终的 url: http://127.0.0.1:5000/students
                pathRewrite: {'^/api1': ''},
                // 是否修改服务器接收到的请求头中 host 字段的值
                // 不配置为 false
                changeOrigin: true
                // changeOrigin: false (真实请求源头) 请求来自于 localhost:3000
                // changeOrigin: true  (虚假请求源头, 伪造为服务器自己) 请求来自于 127.0.0.1:5000
            }
        ),
        // 可以设置多个代理
        proxy(
            // 修改前缀
            '/api2',
            {
                // 修改目标服务器地址
                target: 'http://127.0.0.1:5001',
                // 最终的 url: http://127.0.0.1:5001/students
                pathRewrite: {'^/api2': ''},
                // 修改服务器接收到的请求头中 host 字段的值
                changeOrigin: true
            }
        )
    );
}
```
2. 修改 App.js 中的请求地址
```js
// 两种方式本质一样，都是请求项目自身，再走代理
// api1 前缀说明走代理的 target 为 http://127.0.0.1:5000
const url = "/api1/students";
axios.get(url)
  .then(
      ({data}) => this.refs.me.value = data
  );
```

说明：
1. 两种方案本质一样，前者是后者的简写。
2. 优点：可以配置多个代理，可以灵活的控制请求是否走代理。
3. 缺点：配置繁琐，前端请求资源时必须加前缀。

### 2.2.3. Fetch

fetch 是原生函数，不再使用 XmlHttpRequest 对象提交 Ajax 请求

> [传统 Ajax 已死，Fetch 永生](https://segmentfault.com/a/1190000003810652)

```js
// 使用 fetch 异步发送网络请求
// async/await 是 ES7 的 API
searchByFetch = async (keyword) => {
    try {
        // 使用 await 后，写异步代码就像写同步代码一样
        // await 后面可以跟 Promise 对象，表示等待 Promise resolve() 才会继续向下执行
        // 如果 Promise 被 reject() 或抛出异常则会被外面的 catch 捕获
        const response = await fetch(`/api/search/users?q=${keyword}`);
        const data = await response.json();
        // 请求成功
        console.log(data);
    } catch(error) {
        // 请求失败
        console.log(error);
    }
}
```


### 2.2.4. PubSubJS 消息发布订阅

1. 准备好一个 React App 并安装 `yarn add pubsub-js`

2. 创建好 App 组件和另外两个组件 Provider(消息提供者)、Consumer(消息接收者)
组件间父子关系如下:
```
App
 |- Provider
 |- Consumer
```
代码如下：
App.js
```js
import React, { Component } from 'react';
import Consumer from './Consumer'
import Provider from './Provider'
export default class App extends Component {
    render() {
        return (
            <div>
                <Provider />
                <Consumer />
            </div>
        )
    }
}
```
Provider.js
```js
import React, { Component } from 'react';
// 1. 导入模块 PubSub
import PubSub from 'pubsub-js'
// 消息提供者
export default class Provider extends Component {
    send = () => {
        // 2. 发布消息
        // 参数一: 消息名
        // 参数二: 数据
        PubSub.publish(
            'aBadString',
            'hello, Consumer'
        );
    }
    render() {
        return (
            <button onClick={this.send}>点击发布消息</button>
        );
    }
}
```
Consumer.js
```js
import React, { Component } from 'react';
// 1. 导入模块 PubSub
import PubSub from 'pubsub-js'
// 消息接收者
export default class Consumer extends Component {
    // 组件挂载后执行
    componentDidMount() {
        // 2. 订阅消息
        // 参数一: 消息名
        // 参数二: 收到消息后的回调函数
        this.pubsub = PubSub.subscribe(
            'aBadString', 
            // 回调函数的参数说明
            // 参数一: 消息名
            // 参数二: 数据
            // 不想要参数一, 使用 下划线_
            (_, data) => {
                console.log('收到了', msg, '消息. 内容是', data);
                this.msgDiv.innerHTML = data;
            }
        );
    }
    // 组件即将卸载前执行
    componentWillUnmount() {
        PubSub.unsubscribe(this.pubsub);
    }
    render() {
        return (
            <div ref={ (c) => this.msgDiv = c }></div>
        );
    }
}
```


## 2.3. React Router: SPA

### 2.3.1. SPA 单页面多组件
SPA （single page web application）即单页 Web 应用。整个应用只有一个完整的页面，**单页面多组件**。
点击页面中的链接不会刷新页面，只会做页面的局部更新。数据都需要通过ajax请求获取, 并在前端异步展现。

### 2.3.2. 基本路由组件

1. 先准备好一个 React App 应用，并安装 `yarn add react-router-dom`

2. 再准备好两个组件 Home、About
```jsx
import React, { Component } from 'react';
export default class Home extends Component {
    render() {
        return (
            <h3>我是 Home 的内容</h3>
        );
    }
}
```
```jsx
import React, { Component } from 'react';
export default class About extends Component {
    render() {
        return (
            <h3>我是 About 的内容</h3>
        );
    }
}
```

3. 在 App.js 中编辑
```js
import React, { Component } from 'react';
import {BrowserRouter, Link, NavLink, Route, Switch} from 'react-router-dom';
// Home About 是路由组件
import Home from './page/Home';
import About from './page/About';
// Header 是一般组件
import Header from './component/Header';
import './App.css'

export default class App extends Component {
    render() {
        return (
            <BrowserRouter>
                <Header />
                <div>
                    {/* HTML 中通过 <a> 跳转页面 */}
                    {/* <a className="list-group-item active" href="./about.html">About</a>
                    <a className="list-group-item" href="./home.html">Home</a> */}

                    {/* 编写路由链接 */}
                    {/* React 通过路由链接 Link 切换组件 */}
                    {/* Link 必须放在 BrowserRouter 或 HashRouter 内 */}
                    <Link className="list-group-item" to="/about">About</Link>
                    <Link className="list-group-item" to="/home">Home</Link>

                    {/* Link 组件在点击时并不会切换样式效果
                        而使用 NavLink, 当点击时会给当前被点击标签追加一个 active 类名
                        可以通过 activeClassName 来指定追加的类名, 不指定则默认追加 active */}
                    <NavLink activeClassName="highlight" className="list-group-item" to="/about">About</NavLink>
                    <NavLink activeClassName="highlight" className="list-group-item" to="/home">Home</NavLink>
                </div>
                <div>
                    {/* 注册路由 */}
                    {/* Route 和 Link 必须放在同一个 XxxRouter 内 */}
                    {/* <Route path="/home" component={Home}/>
                    <Route path="/about" component={About}/> */}

                    {/* Route 匹配路由是会从上往下一直执行的, 当第一次匹配上之后, 还会继续往下匹配
                        如果匹配到了多个组件, 则会展示所有组件

                        使用 Switch 组件包裹 Route(路由)
                        当第一次匹配上了路由后, 就不会往下继续匹配了
                        仅展示第一个匹配的组件 */}
                    <Switch>
                        <Route path="/home" component={Home}/>
                        <Route path="/about" component={About}/>
                        {/* 第一个 /home 匹配完后, 不会继续匹配这个路由了 */}
                        <Route path="/home" component={About}/>
                        {/* 当没有匹配上任何路由时, 重定向到 /home */}
                        <Redirect to="/home" />
                    </Switch>
                </div>
            </BrowserRouter>
        )
    }
}
```
在 App.css 文件中定义 NavLink 切换样式
```css
.highlight {
    /* 由于引入了 bootstrap 其样式权重比较高, 导致自定义样式无法展示
       使用 !important 提高样式权重 */
    background-color: orange !important;
    color: white !important;
}
```
- 路由器不能写 Router，必须写具体的 BrowserRouter（/about）或 HashRouter（/#/about）
- 相互关联的路由链接 Link 和路由 Route 必须写在同一个路由器标签中

### 2.3.3. Link 与 NavLink
- Link 组件最终会编译为 a 标签
    ```html
    <a class="list-group-item active" href="/about">About</a>
    ```
- NavLink 组件可在点击时切换样式

**封装 NavLink**
```jsx
import React, { Component } from 'react';
import {NavLink} from 'react-router-dom';
// App.css 可以写到组件的 css 中
import './index.css';

export default class MyNavLink extends Component {
    render() {
        // console.log(this.props);
        return (
            // 标签体内容也是挂在 this.props 上的 children 属性
            // <NavLink>{this.props.children}</NavLink>
            // <NavLink children={this.props.children} />
            // 以上两种写法等价

            // <NavLink activeClassName="highlight" className="list-group-item" {...this.props}>{this.props.children}</NavLink>
            // 以上写法等价于下面写法
            // {...this.props} 展开 props 的全部属性, 等价于 to={this.props.to} children={this.props.children}
            <NavLink activeClassName="highlight" className="list-group-item" {...this.props} />
        );
    }
}

// 这样使用, MyNavLink 是一般组件
<MyNavLink to="/home">Home</MyNavLink>
<MyNavLink to="/about">About</MyNavLink>
```

### 2.3.4. 路由匹配规则（Switch、Route 的 exact 属性、Redirect）
- Route 组件会从上往下匹配，且无论是否匹配上都会继续往下走
- 使用 Switch 组件包裹 Route 组件，则第一次匹配上之后就退出匹配
- 路由的匹配默认是模糊匹配的, 从左往右依次匹配路由的各级路径, 一旦能匹配上一级路径就不往下匹配了
    ```jsx
    {/* 模糊匹配 /home, 不匹配 /home/a /home/a/c */}
    <MyNavLink to="/home/a/c">/home/a/c - 模糊匹配 /home</MyNavLink>
    {/* 不能匹配 /home */}
    <MyNavLink to="/a/home/c">/a/home/c - 没匹配到任何路由</MyNavLink>

    <Switch>
        <Route path="/home" component={Home}/>
        {/* 由于 /home 在前面, /home/a/c 模糊匹配到了 /home, 就不往下走了 */}
        <Route path="/home/a/c" component={About}/>
        {/* 当没有匹配上任何路由时, 重定向到 /about */}
        <Redirect to="/about" />
    </Switch>
    
    {/* 开启精准匹配: exact={true} 或 exact */}
    <Switch>
        <Route exact path="/home" component={Home}/>
        {/* 由于 /home 在前面, /home/a/c 精准匹配不了 /home, 所有继续下一个路由匹配 */}
        <Route path="/home/a/c" component={About}/>
    </Switch>
    {/* 尽量不要使用严格匹配, 可能会导致二级路由无法匹配的问题
        尽量合理设置路由路径和注册顺序 */}
    ```
- 通常情况下，path 和 component 是一一对应的关系，Switch可以提高路由匹配效率（单一匹配）

### 2.3.5. 路由组件与一般组件（history 对象、withRouter 函数）
- 像 Home、About 这样不是使用标签形式挂载到页面上的，而是由路由去选择是否挂载的组件，叫做路由组件。路由组件与一般组件最大的不同是：路由组件的 props 中会接收到 history、location、match 等属性值。
    ```
    history:
        go: ƒ go(n)
        goBack: ƒ goBack()
        goForward: ƒ goForward()
        push: ƒ push(path, state)
        replace: ƒ replace(path, state)

    location:
        pathname: "/about"
        search: ""
        state: undefined

    match:
        params: {}
        path: "/about"
        url: "/about"
    ```
- 路由组件一般放在 src/pages/ 目录下；一般组件一般放在 src/component/ 目录下。
- 为了让一般组件也可以使用路由的 API，可以使用 withRouter 函数加工一下
    ```js
    import React, { Component } from 'react';
    import { withRouter } from "react-router-dom";
    class Header extends Component {
        back = () => {
            // 只有路由组件的 props 中才有 history
            // 但是通过 withRouter 函数加工后的 Header(一般组件) 将会被传入 history
            this.props.history.goBack();
        }
        render() {
            return (
                <div className="page-header">
                    <h2>React Router Demo</h2>
                    <button className="btn btn-xs" onClick={this.back}>后退</button>
                </div>
            );
        }
    }
    // 导出类必须放在定义类后面
    // 因为, 不同于函数, class 的声明是不会提前的
    export default withRouter(Header)
    ```

### 2.3.6. 向路由组件传递参数

**1. Params 参数**
```jsx
// Message 组件向 Detail 组件传递参数

// Message
import React, { Component } from 'react';
import { Link, Route } from 'react-router-dom';
import Detail from './Detail';
export default class Message extends Component {
    state = {
        messageList: [
            {id: '1', title: 'message001'},
            {id: '2', title: 'message002'},
            {id: '3', title: 'message003'}
        ]
    }
    render() {
        const {messageList} = this.state;
        return (
            <div>
                <h2>Message 组件</h2>
                <ul>
                    {
                        messageList.map(
                            (message) => {
                                return (
                                    <li key={message.id}>
                                        {/* 1. 向路由组件传递 params 参数 */}
                                        <Link to={`/home/message/detail/${message.id}`}>{message.title}</Link>
                                    </li>
                                );
                            }
                        )
                    }
                </ul>
                {/* 2. 声明接收 params 参数 */}
                <Route path="/home/message/detail/:id" component={Detail} />
            </div>
        );
    }
}

// Detail
import React, { Component } from 'react';
export default class Detail extends Component {
    state = {
        messageDetailList: [
            {id: '1', title: 'message001', content: 'hello, world'},
            {id: '2', title: 'message002', content: 'hello, China'},
            {id: '3', title: 'message003', content: 'hello, route'}
        ]
    }
    render() {
        // 3. 从 match 中获取 params 参数
        const {id} = this.props.match.params;
        // 通过 id 找到所有信息（模拟 Ajax）
        const detail = this.state.messageDetailList.find(
            (messageDetail) => messageDetail.id === id
        );
        return (
            <div>
                <hr />
                <ul>
                    <li>ID：{detail.id}</li>
                    <li>TITLE：{detail.title}</li>
                    <li>CONTENT：{detail.content}</li>
                </ul>
            </div>
        );
    }
}
```
<table>
  结果：
  <tr>
    <td><img src="../images/React/向路由组件传递参数0.png" /></td>
    <td><img src="../images/React/向路由组件传递参数1.png" /></td>
    <td><img src="../images/React/向路由组件传递参数2.png" /></td>
  </tr>
</table>

**2. search 参数**
```jsx
// Message
{/* 1. 向路由组件传递 search 参数  QueryString */}
<Link to={`/home/message/detail?id=${message.id}`}>{message.title}</Link>
{/* 2. search 参数不用声明接收 */}
<Route path="/home/message/detail" component={Detail} />


// Detail
// QueryString 与 JSON 对象转换
import qs from "querystring";

// 3. 从 location 中获取 search 参数（QueryString 形式  ?id=2）
const {search} = this.props.location;
// 去掉第一个 ? 并转为对象
const {id} = qs.parse(search.slice(1));
```

**3. state 参数**
state 参数内容不会暴露在地址栏
刷新页面后，可以保留参数，因为有 history 对象保留参数
但是如果关闭浏览器在访问则无法保留参数，因为 history 对象被清空了
```jsx
// Message
{/* 1. 向路由组件传递 state 参数  to 的参数是个对象 */}
<Link to={
    {
        pathname: '/home/message/detail',
        state: {
            id: message.id
        } 
    }
}>{message.title}</Link>


// Detail
// 3. 从 location 中获取 state 参数
//  || {}: 如果没有值则取空对象
const {id} = this.props.location.state || {};
```

### 2.3.7. 两种 Router：BrowserRouter、HashRouter
BrowserRouter（/about）；HashRouter（/#/about）
1. path 表现形式不一样
    - BrowserRouter：`localhost:3000/demo/test`。
    - HashRouter：`localhost:3000/#/demo/test`（`#`后面的是锚点，不提交给服务器）。
3. 底层原理不一样：
    - BrowserRouter 使用的是 HTML5 的 history API（this.props.history是对其的封装），不兼容 IE9 及以下版本。
    - HashRouter 使用的是 URL 的哈希值，访问到的始终都是 /index.html。
3. 刷新后对路由 state 参数的影响
    - BrowserRouter 没有任何影响，因为 state 保存在 history 对象中。
    - HashRouter 刷新后会导致路由 state 参数的丢失。
4. 备注：HashRouter 可以用于解决一些路径错误相关的问题（https://pro.ant.design/docs/deploy-cn/#%E4%BD%BF%E7%94%A8-spring-boot）。


## 2.4. React UI: Ant Design

### 2.4.1. 安装使用
先准备好一个 React App 应用，并安装 `yarn add antd`

按钮示例：
```jsx
/* src/App.js */
import React, { Component } from 'react';
// 1. 引入 Button 组件
import { Button } from "antd";
// 2. 引入样式文件
// 请不要这样做, 这样会引入所有的样式. 请按需引入样式.
import "antd/dist/antd.css";

export default class App extends Component {
    render() {
        return (
            // 3. 使用组件
            <div>
                <Button type="primary">Primary Button</Button>
                <Button>Default Button</Button>
                <Button type="dashed">Dashed Button</Button>
                <br />
                <Button type="text">Text Button</Button>
                <Button type="link">Link Button</Button>
            </div>
        );
    }
}
```
![](../images/React/antd1.png)

### 2.4.2. 配置

> https://3x.ant.design/docs/react/use-with-create-react-app-cn#%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE

**准备工作**

1. 安装 react-app-rewired（一个对 create-react-app 进行自定义配置的社区解决方案，其依赖 customize-cra）:
```shell
yarn add react-app-rewired customize-cra
```

2. 修改 package.json 文件中 scripts 属性：
```diff
"scripts": {
-   "start": "react-scripts start",
-   "build": "react-scripts build",
-   "test": "react-scripts test",
+   "start": "react-app-rewired start",
+   "build": "react-app-rewired build",
+   "test": "react-app-rewired test",
    "eject": "react-scripts eject"
},
```

3. 在根目录创建 config-overrides.js 用于写配置


**按需引入样式**
上述例子中 `import "antd/dist/antd.css";` 引入了 antd 的全部样式，会导致文件过大。

1. 安装 `yarn add babel-plugin-import`（按需加载组件代码和样式的 babel 插件）

2. 在 config-overrides.js 文件中配置
```js
const { override, fixBabelImports } = require('customize-cra');

module.exports = override(
  fixBabelImports('import', {
    libraryName: 'antd',
    libraryDirectory: 'es',
    style: 'css',
  }),
);
```

3. 删掉 `src/App.js` 中引入样式的代码 `import "antd/dist/antd.css";`


**自定义主题**

1. 安装 less `yarn add less less-loader`（自定义主题需要用到 less 变量覆盖功能）

2. 在 config-overrides.js 文件中配置
```js
const { override, fixBabelImports, addLessLoader } = require('customize-cra');

module.exports = override(
  fixBabelImports('import', {
    libraryName: 'antd',
    libraryDirectory: 'es',
    style: true
  }),
  addLessLoader({
    // 这里和官网有出入, 官网上的是旧写法, 会报错:
    //     ValidationError: Invalid options object. Less Loader has been initialized using an options object that does not match the API schema.
    //  - options has an unknown property 'modifyVars'. These properties are valid:
    //    object { lessOptions?, additionalData?, sourceMap?, webpackImporter? }
    // 参考 less-loader 文档 https://github.com/webpack-contrib/less-loader#lessoptions
    lessOptions: {
      javascriptEnabled: true,
      // 这里改颜色
      modifyVars: { '@primary-color': 'orange' }
    }
  })
);
```
![](../images/React/antd2.png)


# 3. Vue

- Vue 支持所有兼容 ECMAScript 5 的浏览器
- Vue 是一套用于构建用户界面的渐进式框架。Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，Vue 也完全能够为复杂的单页应用提供驱动。

## 3.1. Hello Vue
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hello Vue</title>
  <!-- 1. 引入 vue.js -->
  <script src="vue.min.js"></script>
</head>
<body>
  <!-- 2. 准备一个容器标签 -->
  <div id="app">
    <!-- 插值表达式  -->
    {{message}}
  </div>

  <script>
    // 3. 创建一个Vue的实例
    var app = new Vue({
        // 表示当前 Vue 实例要控制页面上哪个区域
        el: "#app",
        data: {
          message: "hello, vue"
        }
      });
  </script>
</body>
</html>
```

数据 app.message 与 DOM {{message}} 是双向绑定的。当修改 app.message 的值，对应的页面元素也会改变。


## 3.2. 单向绑定与双向绑定

单向绑定 `v-bind:【标签属性名]="【Vue data 中的 key】"`
```html
<div id="app">
  <p style="color: red;">单向绑定</p>
  <p v-bind:style="myStyle">单向绑定</p>
  <p :style="myStyle">简写单向绑定</p>
</div>
<script>
  var app = new Vue(
    {
      el: "#app",
      data: {
        myStyle: "color: green;"
      }
    }
  );
</script>
```

双向绑定 `v-model:【标签属性名]="【Vue data 中的 key】"`
第一个文本框改变值，其他两个值不变；第二个文本框改变值，其他两个跟着变化。
```html
<div id="app">
  {{message}} <br>
  单向绑定：<input v-bind:value="message" /> <br>
  双向绑定：<input v-model:value="message" />
  <!-- v-model:value="message" 可写为 v-model="message" -->
</div>
<script>
  var app = new Vue(
    {
      el: "#app",
      data: {
        message: "hello"
      }
    }
  );
</script>
```

## 3.3. 事件绑定

`v-on:【事件名称】="【函数调用】"` 或者 `@【事件名称】="【函数调用】"`
```html
<div id="app">
  <button v-on:click="run1">按钮1</button>
  <button v-on:click="run2(1)">按钮2</button>
</div>
<script>
  var app = new Vue(
    {
      el: "#app",
      methods: {
        run1 : () => console.log("hello, v-on"),
        run2(cat) {
          console.log(`hello, ${cat}`)
        }
      }
    }
  );
</script>
```

## 3.4. 条件渲染

```html
<div id="app">
  {{checked}}
  <input type="checkbox" v-model:value="checked" />
  <p v-if="checked">复选框选中了</p>
  <p v-else>复选框未选中</p>
</div>
<script>
  var app = new Vue(
    {
      el: "#app",
      data: {
        checked: false
      }
    }
  );
</script>
```

## 3.5. 循环

```html
<div id="app">
  <ul>
    <li v-for="(user, index) in users" :id="user.id">{{index}}. {{user.name}}</li>
  </ul>
</div>
<script>
  var app = new Vue(
    {
      el: "#app",
      data: {
        users: [
          {id: 1, name: "aBadString"},
          {id: 2, name: "ZK"}
        ]
      }
    }
  );
</script>
```

渲染结果：
```html
<ul>
  <li id="1">0. aBadString</li>
  <li id="2">1. ZK</li>
</ul>
```

## 3.6. created 和网络请求
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>生命周期</title>
  <script src="vue.min.js"></script>
  <script src="axios.min.js"></script>
</head>
<body>
  <div id="app">
    <ul v-if="users && users.length !== 0">
      <li v-for="(user, index) in users" :id="user.id">{{index}}.{{user.name}}</li>
    </ul>
  </div>
  <script>
    var app = new Vue(
      {
        el: "#app",
        data: {
          users: []
        },
        methods: {
          setUsers(users) {
            this.users = users
          }
        },
        // 在页面渲染前执行
        created() {
          axios.get("users.json")
               .then(({data}) => {
                  this.setUsers([])
                  console.log(this.users);
                });
        }
      }
    );
  </script>
</body>
</html>
```