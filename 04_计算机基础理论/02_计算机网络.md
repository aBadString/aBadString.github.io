<h1 id="计算机网络" align="center">计算机网络</h1>
<!-- @import "[TOC]" {cmd="toc"} -->

<!-- code_chunk_output -->

- [1. 从一个 URL 链接开始](#1-从一个-url-链接开始)
  - [1.1. 解析链接的各个部分含义](#11-解析链接的各个部分含义)
  - [1.2. 输入 url 到 显示网页的全过程](#12-输入-url-到-显示网页的全过程)
- [2. 网络分层模型](#2-网络分层模型)
  - [2.1. HTTP/TCP/IP 组成字段](#21-httptcpip-组成字段)
- [3. 网络层与 IP 协议](#3-网络层与-ip-协议)
  - [3.1. IP 地址](#31-ip-地址)
  - [3.2. 网际协议 IP](#32-网际协议-ip)
- [4. 运输层与 TCP 协议](#4-运输层与-tcp-协议)
  - [4.1. 端口](#41-端口)
  - [4.2. TCP 与 UDP 比较](#42-tcp-与-udp-比较)
  - [4.3. 可靠传输原理](#43-可靠传输原理)
    - [4.3.1. 停止等待协议](#431-停止等待协议)
    - [4.3.2. 连续 ARQ 协议](#432-连续-arq-协议)
  - [4.4. TCP](#44-tcp)
    - [4.4.1. TCP 三次握手](#441-tcp-三次握手)
    - [4.4.2. TCP 四次挥手](#442-tcp-四次挥手)
    - [4.4.3. 滑动窗口协议](#443-滑动窗口协议)
    - [4.4.4. 流量控制](#444-流量控制)
    - [4.4.5. 拥塞控制](#445-拥塞控制)
- [5. 应用层与 HTTP 协议](#5-应用层与-http-协议)
  - [5.1. 资源](#51-资源)
    - [5.1.1. 媒体类型 MIME](#511-媒体类型-mime)
    - [5.1.2. URI](#512-uri)
      - [5.1.2.1. URL](#5121-url)
      - [5.1.2.2. URN](#5122-urn)
  - [5.2. HTTP 协议](#52-http-协议)
    - [5.2.1. HTTP 事务](#521-http-事务)
      - [5.2.1.1. 请求方法](#5211-请求方法)
      - [5.2.1.2. 响应状态码](#5212-响应状态码)
    - [5.2.2. HTTP 报文](#522-http-报文)
      - [5.2.2.1. 首部字段](#5221-首部字段)
    - [5.2.3. HTTPS](#523-https)
      - [5.2.3.1. SSL握手](#5231-ssl握手)
    - [5.2.4. 面试题：浏览器禁用 Cookie 怎么办](#524-面试题浏览器禁用-cookie-怎么办)
      - [5.2.4.1. HTTP 是无状态协议](#5241-http-是无状态协议)
      - [5.2.4.2. Cookie 与 Session](#5242-cookie-与-session)
      - [5.2.4.3. Session ID](#5243-session-id)
      - [5.2.4.4. Cookie 被禁用与 URL 重写](#5244-cookie-被禁用与-url-重写)
      - [5.2.4.5. Cookie 被禁用与 Token JWT](#5245-cookie-被禁用与-token-jwt)

<!-- /code_chunk_output -->


# 1. 从一个 URL 链接开始

## 1.1. 解析链接的各个部分含义

```url
https://www.nowcoder.com/discuss/372819?type=all&order=time&pos=&page=6&channel=0&source_id=search_all
```
协议://主机名:端口号/目录/文件名.文件后缀?参数=值&参数=值#标志

**协议**
http、https、file、ftp

**主机名**
主机名可以是一个域名或者一个IP地址，在主机名前面也可以带上连接主机的用户名和密码：
`用户名:密码@子域名.域名.顶级域名.根域名`
一般见到的域名就只有到顶级域名，根域名很少，例如：`http://www.ncu.edu.cn/`

**端口号**
如果使用协议的默认端口号，则可以省略。

**查询字符串 Query String**
以 ? 开始一个查询字符串，以 k=v 的形式表示参数，多个参数之间使用 & 连接。

**锚点**
`#` 2. 代表网页中的一个位置（锚点）。其右面的字符，就是该位置的标识符。比如，http://www.example.com/index.html#print就代表网页index.html的print位置。浏览器读取这个URL后，会自动将print位置滚动至可视区域。
锚点不会被提交，锚点是用来指导浏览器动作的，对服务器端完全无用。所以，HTTP请求中不包括`#`。

## 1.2. 输入 url 到 显示网页的全过程

![img](https://user-gold-cdn.xitu.io/2018/4/19/162db5e985aabdbe?imageslim)

0. 客户端访问本地的hosts文件，检查在该文件中是否有相应的域名、IP对应关系，如果有，则向其IP地址发送请求，如果没有，再去找本地的DNS服务器
1. 浏览器向DNS域名服务器请求解析域名为 IP 地址（迭代查询、递归查询）。
2. 建立 TCP 连接
3. 浏览器向目标服务器发起一个 HTTP 请求，cookies 会随之发送过去。
4. 在运输层通过TCP协议进行数据封装，把一个HTTP会话请求分为若干报文段，添加源端口和目的端口。
5. 网络层则把TCP报文段，划分为不同分组，每个分组各自进行路由选择，最终到达服务器。为确保分组的顺序不乱，需要在发送前给每个分组编号。
6. 服务器收到浏览器的请求后，便会进行逻辑处理，发回一个 HTML 响应。
7. 浏览器接受到 HTML 文件后，进行渲染显示。

**[html 渲染](https://blog.csdn.net/xzm_0602/article/details/53231348)**
1. 下载的顺序是从上到下，渲染的顺序也是从上到下，下载和渲染是同时进行的。 
2. 在渲染到页面的某一部分时，其上面的所有部分都已经下载完成（并不是说所有相关联的元素都已经下载完）。
3. 如果遇到语义解释性的标签嵌入文件（JS脚本，CSS样式），那么此时下载过程会启用单独连接进行下载。 
4. 样式表在下载完成后，将和以前下载的所有样式表一起进行解析，解析完成后，将对此前所有元素（含以前已经渲染的）重新进行渲染。 
5. JS、CSS中如有重定义，后定义函数将覆盖前定义函数。

**reflow（回流）**
浏览器要花时间、花精力去渲染页面，当它发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。 
reflow 几乎是无法避免的。只要引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。 当 然，reflow 问题是可以优化的，我们可以尽量减少不必要的 reflow。比如例子中的 <img> 图片载入问题 —— 给图片设置宽度和高度就可以避免的 reflow。这样浏览器就知道了图片的占位面积，在载入图片前就预留好了位置。
**repaint（重绘）**
repaint，中文叫重绘。如果只是改变某个元素的背景色、文 字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint。


# 2. 网络分层模型

- OSI 7层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
- TCP/IP 4层：网络接口层、网际层(IP)、运输层(TCP)、应用层(HTTP)。
- 5 层：物理层、数据链路层、网络层、运输层、应用层。

各层协议：
- 物理层：RJ45、CLOCK、IEEE802.3   （中继器，集线器，网关） 
- 数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机） 
- 网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器） 
- 传输层：TCP、UDP、SPX 
- 会话层：NFS、SQL、NETBIOS、RPC 
- 表示层：JPEG、MPEG、ASII 
- 应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS

各层作用：
- 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）  
- 数据链路层：将比特组装成帧和点到点的传递（帧Frame）  
- 网络层：负责数据包从源到宿的传递和网际互连（包Package）  
- 传输层：提供端到端的可靠报文传递和错误恢复（段Segment）  
- 会话层：建立、管理和终止会话（会话协议数据单元SPDU）  
- 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）  
- 应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

![七层体系结构图](https://user-gold-cdn.xitu.io/2018/7/29/164e529309f0fa33?imageslim)


**物理层**
单工通信：单向传输
半双工通信：双向交替传输
全双工通信：双向同时传输

**数据链路层**
数据链路层通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。
在两个相邻节点之间传送数据时，数据链路层将网络层交下来的IP数据报**封装成帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。


## 2.1. HTTP/TCP/IP 组成字段
![](../images/HTTP报文TCP段IP分组.png)
![](../images/IPTCPHTTP首部字段.png)


# 3. 网络层与 IP 协议

网络层负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成**分组**和**包**进行传送

**网络层向上只提供灵活的、无连接的、尽最大努力交付的数据报服务。**

在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫**IP数据报**，简称数据报。

互联网是由大量的**异构**（heterogeneous）网络通过**路由器**（router）相互连接起来的。互联网使用的网络层协议是**无连接**的**网际协议（Intert Prococol）**和许多路由选择协议，因此互联网的网络层也叫做**网际层**或**IP层**。


## 3.1. IP 地址

A 类地址：以 0 开头，1.0.0.0~126.255.255.255，前一字节做网络号
B 类地址：以 10 开头，128.1.0.0~191.255.255.255，前两字节做网络号
C 类地址：以 110 开头，192.0.1.0~223.255.255.255，前三字节做网络号
D 类地址：以 1110 开头，224.0.0.0~239.255.255.255，多播地址
E 类地址：以 1111 开头，240.0.0.0~247.255.255.255保留地址

私网地址：10.0.0.0 - 10.255.255.255，172.16.0.0 - 172.31.255.255，192.168.0.0 - 192.168.255.255。

![image-20200330195231897](../images/image-20200330195231897.png)
![image-20200330195424406](../images/image-20200330195424406.png)

## 3.2. 网际协议 IP

![](../images/IP及其配套协议.png)


# 4. 运输层与 TCP 协议

运输层的主要任务就是负责向两台主机**进程**之间的通信提供通用的数据传输服务，端到端的通讯。

运输层：提供端到端（进程到进程）的通讯。属于面向通信部分的最高层，用户功能中的最底层。
只有主机的协议栈才用运输层，路由器最高只到网络层。

## 4.1. 端口

```text
端口号（16位）
  |-- 服务器端使用的端口号
        |-- 熟知端口号/系统端口号 0 - 1023
        |-- 登记端口号 1024 - 49151
  |-- 客户器端使用的端口号 49151 - 65535
```

**套接字 = IP地址:端口号**

## 4.2. TCP 与 UDP 比较

传输控制协议 (Transmission Control Protocol)：面向连接的，可靠的。

1. TCP是面向连接的。（就好像打电话一样，通话前需要先拨号建立连接，通话结束后要挂机释放连接）；
2. TCP提供可靠交付的服务。通过TCP连接传送的数据，无差错、不丢失、不重复、并且**按序**到达；
3. 每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的（一对一）；
4. 面向字节流。TCP中的“流”（stream）指的是流入进程或从进程流出的字节序列。“面向字节流”的含义是：虽然应用程序和TCP的交互是一次一个数据块（大小不等），但TCP把应用程序交下来的数据仅仅看成是一连串的无结构的字节流。

5. TCP提供全双工通信。TCP允许通信双方的应用进程在任何时候都能发送数据。TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；

**TCP一般用于文件传输（FTP）、发送和接收邮件（SMTP）、远程登录（Telnet）等场景。**


用户数据协议 (User Datagram Protocol)：面向无连接的，不保证数据传输的可靠性，尽最大努力传输数据。

1. UDP是无连接的；
2. UDP使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态（这里面有许多参数）；
3. UDP支持一对一、一对多、多对一和多对多的交互通信；
4. UDP是面向报文的；

5. UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）； 
6. UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。

**虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式（一般用于即时通信），比如： QQ语音 QQ视频 、直播等等**

![TCP、UDP协议的区别](https://user-gold-cdn.xitu.io/2018/4/19/162db5e97e9a9e01?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)


**面向连接和非面向连接的服务的特点是什么？**

面向连接的服务，通信双方在进行通信之前，要先在双方建立起一个完整的可以彼此沟通的通道，在通信过程中，整个连接的情况一直可以被实时地监控和管理。 
非面向连接的服务，不需要预先建立一个联络两个通信节点的连接，需要通信的时候，发送节点就可以往网络上发送信息，让信息自主地在网络上去传，一般在传输的过程中不再加以监控。

## 4.3. 可靠传输原理

### 4.3.1. 停止等待协议

- 停止等待协议：每发送完一个分组就停止发送，等待对方确认；在收到确认后再发送下一个分组。
- 超时重传：超时的时间应该比分组的平均往返时延稍长一些。
- 缺点：信道利用率低。

### 4.3.2. 连续 ARQ 协议

- 发送方维护一个发送窗口，一次性发送掉在发送窗口内的所有分组。
- 接收方采用累积确认的方式，对按序到达的最后一个分组发送确认报文。
- 缺点：Go-back-N：当某个分组丢失时，其后面的所有分组都要重传。


## 4.4. TCP

### 4.4.1. TCP 三次握手

![image-20200330202647661](../images/image-20200330202647661.png)

- 第一次握手：客户端发送带有 SYN 标志的数据包给服务器。
- 第二次握手：服务器发送带有 SYN/ACK 标志的数据包给客户端。
- 第三次握手：客户端发送带有 ACK 标志的数据包给服务器。

**为什么是三次握手？**

因为，要确保通讯可靠就需要让双方知道互相发送消息是无误的。

即是要满足以下四点：
1. 客户端要知道 自己发送给服务器的消息可以成功到达；
2. 客户端要知道 服务器发送给自己的消息可以成功到达；
3. 服务器要知道 客户端发送自己给的消息可以成功到达；
4. 服务器要知道 自己发送给客户端的消息可以成功到达。

第一次握手时，服务器知道了 客户端 --> 自己可以到达，满足 3；
第二次握手时，客户端知道了 自己 --> 服务器 和 服务器 --> 自己可以到达，满足1 2；
第三次握手时，服务器知道了 自己 --> 客户端可以到达，满足 4。
所以需要三次，两次不能满足基本的可靠通讯，四次也不能100%的可靠。

**为什么TCP客户端最后还要发送一次确认呢？**
主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。

如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。

如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

### 4.4.2. TCP 四次挥手

TCP 建立连接要进行三次握手，而断开连接要进行四次。这是由于 TCP 的半关闭造成的。因为 TCP 连接是**全双工**的(即数据可在两个方向上同时传递)所以进行关闭时**每个方向上都要单独进行关闭**。这个单方向的关闭就叫半关闭。当一方完成它的数据发送任务，就发送一个 FIN 来向另一方通告将要终止这个方向的连接。

![image-20200330203017880](../images/image-20200330203017880.png)

- 客户端 发送一个 FIN，用来关闭客户端到服务器的数据传输；
- 服务器 收到这个 FIN 后，发回一个 ACK;
- 服务器 关闭与客户端的连接，发送一个 FIN 给客户端；
- 客户端 发回 ACK 报文确认。

为什么客户端发送完最后一个报文需要等待 2 msl?
**1、这是为了确认最后一条报文顺利到达了服务器端。**  
如果最后一条报文丢失了：那么服务器会在 1MSL 时重传倒数第二次的报文，这条报文会在 2MSL 时到达客户端。也就是说，如果客户端在2MSL时收到了一条重传报文，则说明最后一条确认报文丢失了；如果没有收到重传报文，则说明服务器接收到了最后一条确认报文，客户端可以关闭了。 
**2、确保本次连接中所有的报文都从网络中消失**


### 4.4.3. 滑动窗口协议
和连续 ARQ 协议很像
窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小

### 4.4.4. 流量控制

流量控制：控制发送方的发送窗口，让其发送速率不要太快，要让接收方来得及接受。
接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 4.4.5. 拥塞控制

（基于窗口的）拥塞控制四种算法：慢开始、拥塞避免、快重传、快恢复。

cwnd：拥塞窗口，发送方让自己的发送窗口等于拥塞窗口。注意：发送窗口一定小于对于接受窗口。
ssthresh：慢开始门限。
  if cwnd < ssthresh：慢开始
  if cwnd > ssthresh：拥塞避免


慢开始：以指数方式增长滑动窗口。每经过一个传输轮次，拥塞窗口 cwnd 加倍。
拥塞避免：每经过一个往返时间 RTT 就将拥塞窗口加一。
快重传：接受方发现有个别报文丢失时，会立即连续的发送三个相同的确认报文（而不会等待捎带确认）；发送方收到 3-ACK，就会对丢失的报文立即重传。
快恢复：ssthresh = cwnd / 2，cwnd = ssthresh

当超时：重新进入慢开始；当收到三个重复的确认报文（快重传）时，进入拥塞避免

![image-20200413165646760](../images/image-20200413165646760.png)
1、cwnd == ssthresh == 16 时：改用拥塞避免算法；
2、网络出现超时，发送方判断出现网络拥塞：ssthresh = cwnd / 2 = 12，cwnd = 1，进入慢开始；
3、同 1；
4、发送方连续收到 3 个相同的确认报文（此次使用快重传）：
5、快重传后，执行快恢复：ssthresh = cwnd / 2，cwnd = ssthresh，进入拥塞避免


# 5. 应用层与 HTTP 协议

![image-20200330202554664](../images/image-20200330202554664.png)

TCP:
- FTP：21，文件传输协议
- Telnet：23，远程登陆
- SMTP：25，邮件传送协议，发送邮件
- POP3：110，邮件传送协议，接受邮件
- HTTP：80，从 Web 服务器传输超文本到本地浏览器的协议

UDP:
- DNS：53，域名解析服务
- SNMP：161，简单网络管理协议
- TFTP：69，简单文件传输协议

## 5.1. 资源

Web 服务器是 web 资源的宿主，资源包括静态资源和动态资源。

### 5.1.1. 媒体类型 MIME

Multipurpose Internet Mail Extension，多用途因特网邮件扩展

互联网上的资源有多种类型，HTTP 协议通过使用 MIME 数据格式给每个资源打上不同的标签。
MIME 类型是一种文本标记，表示一种主要的对象类型和一个特定的子类型，中间 由一条斜杠来分隔。
- HTML 格式的文本文档由 text/html 类型来标记。
- 普通的 ASCII 文本文档由 text/plain 类型来标记。
- JPEG 版本的图片为 image/jpeg 类型。
- GIF 格式的图片为 image/gif 类型。
- Apple 的 QuickTime 电影为 video/quicktime 类型。
- 微软的 PowerPoint 演示文件为 application/vnd.ms-powerpoint 类型。

### 5.1.2. URI

URI 统一资源标识符，用字符串标识某一互联网资源；URI 有两种形式，分别称为 URL 和 URN。
![image-20200410155806316](../images/image-20200410155806316.png)

#### 5.1.2.1. URL

URL 统一资源定位符，表示资源在互联网上所处的位置。它可以明确说明如何从一个精确、固定的位置获取资源。
URL 的格式
![image-20200410155836768](../images/image-20200410155836768.png)

URL 包括三个部分：
- 第一部分：方案（scheme），说明了访问资源所使用的协议类型。通常就是 HTTP 协议（http://）
- 第二部分：给出了服务器的因特网地址（比如，www.joes-hardware.com）
- 其余部分：指定了 Web 服务器上的某个资源（比如，/specials/saw-blade.gif）

#### 5.1.2.2. URN

- URN 是作为特定内容的唯一名称使用的，与目前的资源所在地无关。
- 使用这些与位置无关的 URN，就可以将资源四处搬移。
- 通过 URN，还可以用同一个名字通过多种网络访问协议来访问资源。

> 比如，不论因特网标准文档 RFC 2141 位于何处（甚至可以将其复制到多个地方）， 都可以用下列 URN 来命名它： urn:ietf:rfc:2141

![](https://cs-notes-1256109796.cos.ap-guangzhou.myqcloud.com/8441b2c4-dca7-4d6b-8efb-f22efccaf331.png)

## 5.2. HTTP 协议

HTTP 是面向事务的应用层协议。HTTP 协议是无状态的。

### 5.2.1. HTTP 事务

一个 HTTP 事务由一条请求命令和一个响应结果组成。这种通信是通过名为 HTTP 报文（HTTP message）的格式化数据块进行的。

#### 5.2.1.1. 请求方法

**RESTful**:
REST，即Representational State Transfer 表现层状态转化
- GET（SELECT）：从服务器取出资源（一项或多项）。
- POST（CREATE）：在服务器新建一个资源。
- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。(id, new Object)
- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。
- DELETE（DELETE）：从服务器删除资源。
- HEAD：获取资源的元数据。仅发送命名资源响应中的 HTTP 首部。
- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。

**幂等**:
HTTP 幂等方法，是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。
- GET：用于获取资源，不管调用多少次接口，结果都不会改变，所以是**幂等的**。
- POST：是一个**非幂等**方法，因为调用多次，都将产生新的资源。
- PUT：因为它直接把实体部分的数据替换到服务器的资源，我们多次调用它，只会产生一次影响，但是有相同结果的 HTTP 方法，所以满足**幂等性**。
- PATCH：我们服务端对方法的处理是，当调用一次方法，更新部分字段，将这条 ticket 记录的操作记录加一，这次，每次调用的资源是不是变了呢，所以它是有可能是**非幂等**的操作。比如点赞按钮。
- DELETE：调用一次和多次对资源产生影响是相同的，所以也满足**幂等性**。

**get 和 post 的区别**

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。

- GET参数通过URL传递，POST放在Request body中。
- GET请求在URL中传送的参数是有长度限制的，而POST没有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET请求只能进行 url 编码，而POST支持多种编码方式。

- GET产生的URL地址可以被Bookmark，而POST不可以。(Bookmark:加入书签)
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。

- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。

- GET产生一个TCP数据包；POST产生两个TCP数据包。
对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。


#### 5.2.1.2. 响应状态码

1XX：Information 信息性状态码，接受到请求正在处理
2XX：Success 成功状态码，请求正常处理完毕
3XX：Redirection 重定向状态码，需要进行附加操作以完成请求
4XX：Client Error 客户端错误状态码，服务器无法处理请求
5XX：Server Error 服务器错误状态码，服务器处理请求错误

- 200 OK：**请求已正常处理**
- 201 Created：**资源创建成功**
- 204 No Content：**请求处理成功，但没有任何资源可以返回给客户端**，一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。
- 206 Partial Content：**是对资源某一部分的请求**，该状态码表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容。

- 301 Moved Permanently：**永久性重定向**。资源的 url 已更新，你也更新下你的书签引用吧。请求的资源已经被分配了新的URI，以后应使用资源现在所指的URI。
- 302 Found：**临时性重定向**。资源的URI已临时定位到其他位置了，姑且算你已经知道了这个情况了。和301相似，但302代表的资源不是永久性移动，只是临时性性质的。换句话说，已移动的资源对应的URI将来还有可能发生改变。
- 303 See Other：资源的URI已更新，你是否能临时按新的URI访问。该状态码表示由于请求对应的资源存在着另一个URL，应使用GET方法定向获取请求的资源。303状态码和302状态码有着相同的功能，但303状态码明确表示客户端应当采用GET方法获取资源，这点与302状态码有区别。
- 304 Not Modified：资源已找到，但未符合条件请求。
- 307 Temporary Redirect：临时重定向。与302有相同的含义。

- 400 Bad Request：服务器端无法理解客户端发送的请求，**请求报文中可能存在语法错误**。
- 401 Unauthorized：该状态码表示发送的请求需要有通过HTTP认证（BASIC认证，DIGEST认证）的认证信息。
- 403 Forbidden：**不允许访问**那个资源。该状态码表明对请求资源的访问被服务器拒绝了。（权限，未授权IP等）
- 404 Not Found：服务器上没有请求的资源。路径错误等。

- 500 Internal Server Error：貌似**内部资源出故障了**。该状态码表明服务器端在执行请求时发生了错误。也有可能是web应用存在bug或某些临时故障。
- 503 Service Unavailable：抱歉，我现在**正在忙着**。该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。

**状态码** http://www.ruanyifeng.com/blog/2014/05/restful_api.html

- 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。
- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。
- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）
- 204 NO CONTENT - [DELETE]：用户删除数据成功。

- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。
- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。
- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。
- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。
- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。
- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。
- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。

- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。


### 5.2.2. HTTP 报文

```http
POST http://127.0.0.1:5000/songlist
Accept: */*
Cache-Control: no-cache
Content-Type: application/json
Authorization: eyJ0eXAi...

{ "name": "松松的歌单" }
```

HTTP 报文都是纯文本
```text
HTTP 报文
    |-- 请求报文
        |-- 请求起始行：请求方法 URI 协议版本
        |-- 请求首部字段
        |-- 请求主体
    |-- 响应报文
        |-- 响应起始行：协议版本 状态码 原因短语
        |-- 响应首部字段
        |-- 响应主体
```

HTTP 是无状态协议。
请求报文由 请求方法、请求 URI、协议版本、请求首部字段(可选)、内容实体 构成。
![image-20200410160414485](../images/image-20200410160414485.png)

响应报文由 协议版本、状态码、原因短语、响应首部字段(可选)、实体主体 构成。
![image-20200410161101659](../images/image-20200410161101659.png) 

#### 5.2.2.1. 首部字段

> https://www.cnblogs.com/xzsty/p/11452610.html

**1、通用首部字段**
请求报文和响应报文都会使用到的首部字段。

|首部字段名|含义|
|:-:|:-:|
|==Cache-Control==|==控制缓存的行为==|
|Connection|连接的管理|
|Date|创建报文的日期时间|
|Pragma|报文指令|
|Trailer|报文末端的首部一览|
|Transfer-Encoding|指定报文主体的传输编码方式|
|Upgrade|升级为其他协议|
|Via|代理服务器的相关信息|
|Warning|错误通知|

**2、请求首部字段**
|首部字段名|含义|
|:-:|:-:|
|==Accept==|==用户代理可处理的媒体类型==|
|Accept-Charset|优先的字符集|
|Accept-Encoding|优先的内容编码|
|Accept-Language|优先的语言（自然语言）|
|Authorization|Web认证信息|
|Expect|期待服务器的特定行为|
|From|用户的电子邮箱地址|
|==Host==|==请求资源所在服务器==|
|If-Match|比较实体标记（ETag）|
|If-Modified-Since|比较资源的更新时间|
|If-None-Match|比较实体标记（与 If-Match 相反）|
|If-Range|资源未更新时发送实体 Byte 的范围请求|
|If-Unmodified-Since|比较资源的更新时间（与If-Modified-Since相反）|
|Max-Forwards|最大传输逐跳数|
|Proxy-Authorization|代理服务器要求客户端的认证信息|
|Range|实体的字节范围请求|
|Referer|对请求中URI的原始获取方|
|TE|传输编码的优先级|
|User-Agent|HTTP客户端程序的信息|

**3、响应首部字段**
|首部字段名|含义|
|:-:|:-:|
|Accept-Ranges|是否接受字节范围请求|
|==Age==|==推算资源创建经过时间==|
|ETag|资源的匹配信息|
|==Location==|==令客户端重定向至指定URI==|
|Proxy-Authenticate|代理服务器对客户端的认证信息|
|Retry-After|对再次发起请求的时机要求|
|==Server==|==HTTP服务器的安装信息==|
|Vary|代理服务器缓存的管理信息|
|WWW-Authenticate|服务器对客户端的认证信息|

**4、实体首部字段**
|首部字段名|含义|
|:-:|:-:|
|Allow|资源可支持的HTTP方法|
|Content-Encoding|实体主体适用的编码方式|
|Content-Language|实体主体的自然语言|
|==Content-Length==|==实体主体的大小（单位：字节）==|
|Content-Location|替代对应资源的URI|
|Content-MD5|实体主体的报文摘要|
|Content-Range|实体主体的位置范围|
|==Content-Type==|==实体主体的媒体类型==|
|Expires|实体主体过期的日期时间|
|Last-Modified|资源的最后修改日期时间|

**几个重要首部字段及其指令**

【1、Cache-Control】
|缓存请求指令|参数|含义|
|:-:|:-:|:-:|
|no-cache|无|强制向原服务器再次验证|
|no-store|无|不缓存请求或响应的任何内容|
|max-age = [ 秒]|必须|响应的最大Age值|
|max-stale( = [ 秒])|可省略|接收已过期的响应|
|min-fresh = [ 秒]|必需|期望在指定的时间内的响应仍有效|
|no-transform|无|代理不可更改媒体类型|
|only-if-cached|无|代理不可更改媒体类型|
|cache-extension|无|新指令标记（token）|

|缓存响应指令|参数|含义|
|:-:|:-:|:-:|
|public|无|可向任意方提供响应的缓存|
|private|可省略|仅向特定用户返回响应|
|no-cache|可省略|缓存前必需先确认其有效性|
|no-store|无|不缓存请求或响应的任何内容|
|no-transform|无|代理不可更改媒体类型|
|must-revalidate|无|可缓存但必须再向源服务器进行确认|
|proxy-revalidate|无|要求中间缓存服务器对缓存的响应有效性再进行确认|
|max-age=[秒]|必需|响应的最大Age值|
|s-maxage=[秒]|必需|公共缓存服务器响应的最大Age值|
|cache-extension|-|新指令标记（token）|


### 5.2.3. HTTPS

HTTP协议以明文方式发送内容，不提供任何方式的数据加密。

HTTP + 加密 + 认证 + 完整性保护 = HTTPS

安全套接字层 超文本传输协议HTTPS：为了数据传输的安全，**在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密**。

HTTPS 的作用：1、建立一个安全的信息通道；2、确认网站的真实性。

**HTTP与HTTPS的区别:**
1. HTTPS 需要申请 CA 证书。
2. HTTP 是明文传输数据的；HTTPS则是具有安全性的SSL加密传输协议。
3. HTTP 默认端口号 80；HTTPS 默认端口号 443。
4. HTTP 连接比较简单，是无状态的；HTTPS 可以加密传输和进行身份认证。
5. HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 SSL 握手需要的 9 个包，所以一共是 12 个包。

#### 5.2.3.1. SSL握手

在发送已加密的 HTTP 报文之前，客户端和服务器要进行一次 SSL 握手，需要完成一下任务：
- 交换协议版本号； 
- 选择一个两端都了解的密码； 
- 对两端的身份进行认证； 
- 生成临时的会话密钥，以便加密信道。

**HTTPS 的连接流程：**
- TCP 三次握手
- 客户端向服务器发送自己支持的加密算法，并请求服务器的数字证书。
- 服务器进行算法协商。将协商好的加密算法和公钥，以及自己的数字证书发给客户端。
- 客户端验证服务器数字证书。生成会话使用的对称密钥。然后使用服务器的公钥将会话密钥加密发给服务器。
- 服务器使用私钥解码会话密钥。
- SSL 安全加密隧道协商完成，之后的通讯就可以使用对称的会话密钥进行了。

网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。

**客户端验证证书：**
客户端在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。

**算法协商：**
1. 浏览器把自己支持的密钥算法套件发给服务器
2. 服务器接受到后，与自己支持的套件做对比。如果找到双方都支持的，则告知浏览器；如果没有，则浏览器会报错。
3. 浏览器和服务器使用匹配的密钥算法套件进行通讯。

```sequence
client -> server : 1.SSL版本，支持的加密算法，请求数字证书
server -> server : 2.进行算法协商
server -> client : 3.SSL版本，协商好的加密算法，服务器公钥，数字证书
client -> client : 4.验证数字证书，生成对称的会话密钥
client -> server : 5.经服务器公钥加密后的会话密钥
server -> server : 6.使用私钥解密会话密钥

client -> server : 7.经对称的会话密钥加密的请求报文
server -> client : 8.经对称的会话密钥加密的响应报文
```

```sequence
client -> server : 1.Handshake: ClientHello  （SSL版本，加密组件）

server -> client : 2.Handshake: ServerHello  （SSL版本，协商后的加密组件）
server -> client : 3.Handshake: Certificate  （公钥，证书）
server -> client : 4.Handshake: ServerHelloDone  （第一次握手结束：协商阶段）

client -> server : 5.Handshake: ClientKeyExchange  （公钥加密后的会话密钥）
client -> server : 6.ChangeClipherSpec  （会话密钥加密的）
client -> server : 7.Handshake: Finished  （前面所有报文的整体校验值。第二次握手结束：会话密钥）

server -> client : 8.ChangeClipherSpec  （同上，6和8是为了测试双方都可以使用会话密钥进行通信）
server -> client : 9.Handshake: Finished  （第三次握手结束：确认通信）
```

Handshake 握手
Certificate 证书


### 5.2.4. 面试题：浏览器禁用 Cookie 怎么办

#### 5.2.4.1. HTTP 是无状态协议

由于 HTTP 请求是无状态的，该协议对于交互性场景没有记忆能力，不能保留会话。

如果请求多个接口之间没有依赖关系，那么这种无状态的 HTTP 协议是完全没有问题的。
但是当我们的接口之间存在依赖关系：例如一个购物场景：
1. 接口 A：登录接口
2. 接口 B：将一个商品加入购物车
3. 接口 C：支付购买商品
这就有问题了，像这种场景我们就需要保留会话信息。

#### 5.2.4.2. Cookie 与 Session

为了保留会话信息，Cookie 与 Session 便产生了。

- Cookie 是一种保存在客户端的会话状态储存机制。它是服务器在本地机器上存储的小段文本或者是内存中的一段数据。每次向服务器发生请求是都会附带上该请求域的 Cookie 一起发送至服务器。Cookie 是不可以直接跨域的。
- Session 是另一种记录客户状态的机制，不同的是Cookie保存在客户端浏览器中，而Session保存在服务器上。

像上述购物场景中所需要保存的信息是一些涉及安全的信息，不能够被随意篡改的。所有这些信息应该是只能保存在服务器端的，而且这些信息应该是每个登录用户独占一份且互不干扰的。所有它们应该是保存在 Session 中的。

#### 5.2.4.3. Session ID

因为每次 HTTP 请求都是无关联的，即使通过 Session 记录了会话的信息。但每个用户都会有一个 Session，那么如何确定哪个 Session 是属于哪个用户(请求)的呢？

实际上，在 Session 被创建时会给其分配一个 Session ID，这个 ID 在服务器响应时将其写入到 Cookie 中。浏览器在当前会话期间内将保存这个 Cookie，并且在每次请求时都带上 Cookie 给服务器。这样服务器就能够确定哪个请求对应哪个 Sesion。

==TODO: 这里还可以讲到 Session ID 的生成策略、如何保证 Session ID 的安全（既不重复，又难以伪造）。==

#### 5.2.4.4. Cookie 被禁用与 URL 重写

那么如果浏览器禁用了 Cookie 怎么办嘛？
若是如此，服务器就无法通过 Cookie 来获取 Session ID，只能想其他方法保存。

我们可以知道，在用户第一次访问时，服务器会响应给浏览器一个 HTML 页面，同时创建一个 Session 及其 ID。
之后用户的所有操作（点击页面功能）都会通过点击一个 URL 来和服务器通讯。那么我们就可以在 URL 上做手脚，将 Session ID 带在 URL 上。这样用户之后的操作就可以从 URL 中获取到 Session ID。

#### 5.2.4.5. Cookie 被禁用与 Token JWT

==TODO==