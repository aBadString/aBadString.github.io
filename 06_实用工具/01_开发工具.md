<h1 id="Tool" align="center">开发工具</h1>
<!-- @import "[TOC]" {cmd="toc"} -->

<!-- code_chunk_output -->

- [1. Git](#1-git)
  - [1.1. Git 基础](#11-git-基础)
    - [1.1.1. 设置全局配置信息](#111-设置全局配置信息)
    - [1.1.2. 使用 Git 仓库](#112-使用-git-仓库)
    - [1.1.3. 版本回退](#113-版本回退)
    - [1.1.4. 工作区和暂存区](#114-工作区和暂存区)
    - [1.1.5. 分支](#115-分支)
    - [1.1.6. 冲突](#116-冲突)
    - [1.1.7. 存储工作现场](#117-存储工作现场)
    - [1.1.8. 推送和抓取远程分支](#118-推送和抓取远程分支)
    - [1.1.9. 标签](#119-标签)
    - [1.1.10. gitignore](#1110-gitignore)
  - [1.2. Git 常用命令](#12-git-常用命令)
  - [1.3. Git Commit message 编写指南](#13-git-commit-message-编写指南)
    - [1.3.1. Header 包括三部分](#131-header-包括三部分)
  - [1.4. Git 开发模式](#14-git-开发模式)
    - [1.4.1. 分支模式](#141-分支模式)
    - [1.4.2. Git-flow 模式](#142-git-flow-模式)
    - [1.4.3. 主干模式](#143-主干模式)
  - [1.5. 配置 GitHub 的 SSH 密钥](#15-配置-github-的-ssh-密钥)
  - [1.6. 配置备份仓库](#16-配置备份仓库)
  - [1.7. GitLab](#17-gitlab)
    - [1.7.1. Docker 安装](#171-docker-安装)
    - [1.7.2. 备份](#172-备份)
- [2. Maven](#2-maven)
  - [2.1. 需要做的配置](#21-需要做的配置)
  - [2.2. Maven 简介](#22-maven-简介)
    - [2.2.1. 约定配置](#221-约定配置)
    - [2.2.2. POM (Project Object Model 项目对象模型)](#222-pom-project-object-model-项目对象模型)
  - [2.3. Maven 命令](#23-maven-命令)
    - [2.3.1. package、install、deploy的联系与区别](#231-package-install-deploy的联系与区别)
  - [2.4. 常见问题](#24-常见问题)
- [3. Gradle](#3-gradle)
  - [3.1. 安装配置](#31-安装配置)
- [4. Docker](#4-docker)
  - [4.1. Docker 的安装和启动](#41-docker-的安装和启动)
  - [4.2. Docker常用命令](#42-docker常用命令)
    - [4.2.1. 配置Docker 加速](#421-配置docker-加速)
    - [4.2.2. 镜像操作](#422-镜像操作)
    - [4.2.3. 容器操作](#423-容器操作)
    - [4.2.4. 安装 MySQL 和 Tomcat](#424-安装-mysql-和-tomcat)
    - [4.2.5. 配置 Docker 远程连接](#425-配置-docker-远程连接)
  - [4.3. Dockerfile](#43-dockerfile)
    - [4.3.1. 使用 Dockerfile 定制镜像](#431-使用-dockerfile-定制镜像)
    - [4.3.2. 指令](#432-指令)
    - [4.3.3. Docker 镜像制作](#433-docker-镜像制作)
      - [4.3.3.1. JRE 镜像](#4331-jre-镜像)
- [5. Shell](#5-shell)
  - [5.1. 变量](#51-变量)
  - [5.2. 字符串](#52-字符串)
  - [5.3. 数组](#53-数组)
  - [5.4. 注释](#54-注释)
  - [5.5. 命令行参数](#55-命令行参数)
  - [5.6. 基本运算符](#56-基本运算符)
- [6. VMWare 虚拟机](#6-vmware-虚拟机)
  - [6.1. 文件](#61-文件)
  - [6.2. VMware 虚拟机三种网络模式](#62-vmware-虚拟机三种网络模式)
- [7. Ubuntu](#7-ubuntu)
  - [7.1. 换源](#71-换源)
  - [7.2. 设置时区](#72-设置时区)
  - [7.3. 安装 SSH](#73-安装-ssh)
    - [7.3.1. SSH 公钥登录](#731-ssh-公钥登录)
  - [7.4. 修改登录 Banner](#74-修改登录-banner)
  - [7.5. 固定IP地址](#75-固定ip地址)
    - [7.5.1. 虚拟机桥接模式下固定静态 IP 地址](#751-虚拟机桥接模式下固定静态-ip-地址)
    - [7.5.2. 虚拟机 NAT 模式下固定静态 IP 地址](#752-虚拟机-nat-模式下固定静态-ip-地址)
      - [7.5.2.1. 解决虚拟机无法连接注解和外部网络的问题](#7521-解决虚拟机无法连接注解和外部网络的问题)
    - [7.5.3. nmap](#753-nmap)
  - [7.6. 文件上传](#76-文件上传)
  - [7.7. 常见问题](#77-常见问题)
- [8. CMD](#8-cmd)
  - [8.1. 批处理清理VS工程目录（递归删除Debug, Release, ipch目录及*.sdf文件）](#81-批处理清理vs工程目录递归删除debug-release-ipch目录及sdf文件)
- [9. Markdown](#9-markdown)
- [10. 基于项目的文件夹分类与命名规范](#10-基于项目的文件夹分类与命名规范)
- [11. 正则表达式](#11-正则表达式)
  - [11.1. 限定符](#111-限定符)
  - [11.2. 或运算符](#112-或运算符)
  - [11.3. 字符集合](#113-字符集合)
  - [11.4. 元字符](#114-元字符)
  - [11.5. 实例](#115-实例)

<!-- /code_chunk_output -->

# 1. Git

## 1.1. Git 基础

Git 是 C 语言开发的分布式的版本控制系统，而 SVN 是集中式的版本控制系统。Git 的客户端不只是提取最新版本的快照，而且将整个代码仓库镜像复制下来。

**为什么要使用Git**
- 能够对文件版本控制和多人协作开发
- 拥有强大的分支特性，所以能够灵活地以不同的工作流协同开发
- 分布式版本控制系统，即使协作服务器宕机，也能继续提交代码或文件到本地仓库，当协作服务器恢复正常工作时，再将本地仓库同步到远程仓库。
- 当团队中某个成员完成某个功能时，通过pull request操作来通知其他团队成员，其他团队成员能够review code后再合并代码。
> 作者：Sam_Lau
> 链接：https://www.jianshu.com/p/67afe711c731



### 1.1.1. 设置全局配置信息

```shell
# 设置设置全局用户名和邮箱
git config --global user.name "Your Name"
git config --global user.email "email@example.com"
# 查看全局配置信息
git config --global --list
```

### 1.1.2. 使用 Git 仓库

初始化一个Git仓库，使用 `git init` 命令。

添加文件到Git仓库，分两步：  
使用命令 `git add <file>` ，注意，可反复多次使用，添加多个文件；  
使用命令 `git commit -m <message>` ，完成。

要随时掌握工作区的状态，使用 `git status` 命令。

如果git status告诉你有文件被修改过，用 `git diff` 可以查看修改内容。

### 1.1.3. 版本回退

HEAD指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令 `git reset --hard [commit_id]` （上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100）。

穿梭前，用 `git log` 可以查看提交历史，以便确定要回退到哪个版本。
`git log --oneline` 每条 log 显示在一行内
`git log --graph `  树形显示

要重返未来，用 `git reflog` 查看命令历史，以便确定要回到未来的哪个版本。

```shell
# 撤销上一次 git commit, 但不删除文件
git reset --soft HEAD^

# 完全回退到以前版本，之后修改的文件全部消失，git commit 记录也没有了
git reset --hard HEAD^         # 回退到上个版本
git reset --hard HEAD~3        # 回退到前3次提交之前，以此类推，回退到n次提交之前
git reset --hard commit_id     # 退到/进到 指定commit的sha码

# 强推到远程：
git push origin HEAD --force
```
- hard 修改版本库，修改暂存区，修改工作区：全部会回退到以前版本。
- soft 修改版本库，保留暂存区，保留工作区：相当于把目标版本之后的变更都移动到暂存区。
- git revert 是用一次新的 commit 来回滚之前的 commit；git reset 是直接删除指定的 commit。
> [git reset --hard --soft 与 git revert 的作用](https://www.jianshu.com/p/952d83fc5bc8)

### 1.1.4. 工作区和暂存区

工作区：电脑里能看到的目录，当前文件资源管理器直接看到的目录。  
版本库：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。

第一步是用git add把文件添加进去，实际上就是把文件修改添加到暂存区；  
第二步是用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。

```shell
# 将工作区中修改后的 readme.txt 恢复到 暂存区版本（工作区中的 readme.txt 内容变为暂存区中的内容 ）
git resotre readme.txt

# 将暂存区中修改后的 readme.txt 恢复到 本地仓库版本 ，回滚 git add (不影响工作区中的 readme.txt 的内容)
git restore --staged readme.txt
```

### 1.1.5. 分支

查看分支：`git branch` `git branch -a`

创建分支：`git branch <name>`

切换分支：`git checkout <name>` 或者 `git switch <name>`

创建+切换分支：`git checkout -b <name>` 或者 `git switch -c <name>`

合并某分支到当前分支：`git merge <name>`  
`git merge --no-ff -m "<合并消息>" <name>` --no-ff 会保留分支历史

删除分支：`git branch -d <name>`  
如果要丢弃一个没有被合并过的分支，可以通过 `git branch -D <name>` 强行删除。

### 1.1.6. 冲突

回到解决冲突之前的状态：`git merge --abort`

### 1.1.7. 存储工作现场

存储被Git管理的文件：`git stash`，再用 git status 查看就是干净的，注意没有被 git 追踪的文件不会被存储

查看存储的现场：`git stash list`

用 `git stash apply` 恢复，再用 `git stash drop` 来删除；

用 `git stash pop`，恢复的同时把stash内容也删了：

### 1.1.8. 推送和抓取远程分支

查看远程库信息：`git remote -v`

本地新建的分支如果不推送到远程，对其他人就是不可见的；

从本地推送分支：`git push origin <branch-name>`，如果推送失败，先用git pull抓取远程的新提交；

在本地创建和远程分支对应的分支：`git checkout -b <branch-name> origin/<branch-name>`，本地和远程分支的名称最好一致；

建立本地分支和远程分支的关联： `git branch --set-upstream <branch-name> origin/<branch-name>`；

从远程拉取分支：`git pull`

### 1.1.9. 标签

给本次提交添加 tag：`git tag v1.0`  
给指定的提交添加 tag：`git tag v1.0 <commit id>`  
创建带有说明的标签，用-a指定标签名，-m指定说明文字：`git tag -a v0.1 -m "version 0.1 released" 1094adb`

查看标签：`git tag`

推送某个标签到远程：`git push origin <tagname>`  
一次性推送全部尚未推送到远程的本地标签：`git push origin --tags`

删除本地标签：`git tag -d v0.9`   
删除远程标签：`git push origin :refs/tags/v0.9`

### 1.1.10. gitignore

检查.gitignore文件书写是否正确：`git check-ignore`  
`git check-ignore -v App.class`

**.gitignore忽略规则简单说明**
> https://www.cnblogs.com/kevingrace/p/5690241.html
```gitignore
#               表示此为注释,将被Git忽略
*.a             表示忽略所有 .a 结尾的文件
!lib.a          表示但lib.a除外
/TODO           表示仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/          表示忽略 build/目录下的所有文件，过滤整个build文件夹；
doc/*.txt       表示会忽略doc/notes.txt但不包括 doc/server/arch.txt
 
bin/:           表示忽略当前路径下的bin文件夹，该文件夹下的所有内容都会被忽略，不忽略 bin 文件
/bin:           表示忽略根目录下的bin文件
/*.c:           表示忽略cat.c，不忽略 build/cat.c
debug/*.obj:    表示忽略debug/io.obj，不忽略 debug/common/io.obj和tools/debug/io.obj
**/foo:         表示忽略/foo,a/foo,a/b/foo等
a/**/b:         表示忽略a/b, a/x/b,a/x/y/b等
!/bin/run.sh    表示不忽略bin目录下的run.sh文件
*.log:          表示忽略所有 .log 文件
config.php:     表示忽略当前路径的 config.php 文件
 
/mtk/           表示过滤整个文件夹
*.zip           表示过滤所有.zip文件
/mtk/do.c       表示过滤某个具体文件
 
被过滤掉的文件就不会出现在git仓库中（gitlab或github）了，当然本地库中还有，只是push的时候不会上传。
 
需要注意的是，gitignore还可以指定要将哪些文件添加到版本管理中，如下：
!*.zip
!/mtk/one.txt
 
唯一的区别就是规则开头多了一个感叹号，Git会将满足这类规则的文件添加到版本管理中。为什么要有两种规则呢？
想象一个场景：假如我们只需要管理/mtk/目录中的one.txt文件，这个目录中的其他文件都不需要管理，那么.gitignore规则应写为：：
/mtk/*
!/mtk/one.txt
 
假设我们只有过滤规则，而没有添加规则，那么我们就需要把/mtk/目录下除了one.txt以外的所有文件都写出来！
注意上面的/mtk/*不能写为/mtk/，否则父目录被前面的规则排除掉了，one.txt文件虽然加了!过滤规则，也不会生效！
 
----------------------------------------------------------------------------------
还有一些规则如下：
fd1/*
说明：忽略目录 fd1 下的全部内容；注意，不管是根目录下的 /fd1/ 目录，还是某个子目录 /child/fd1/ 目录，都会被忽略；
 
/fd1/*
说明：忽略根目录下的 /fd1/ 目录的全部内容；
 
/*
!.gitignore
!/fw/ 
/fw/*
!/fw/bin/
!/fw/sf/
说明：忽略全部内容，但是不忽略 .gitignore 文件、根目录下的 /fw/bin/ 和 /fw/sf/ 目录；注意要先对bin/的父目录使用!规则，使其不被排除。
```

## 1.2. Git 常用命令

```bash
# 配置并查看全局信息
git config --global user.name 'aBadString'
git config --global user.email ''
git config -l

# 初始化
git init

# 连接远程库
git remote add origin http...
# 查看本地变化
git status

# 提交
git add *
git commit -m 'first_commit'
git push -u origin master

# 删除暂存区的文件，不删除工作区的文件
git rm -r --cached 文件名
# 撤销上一次 git add
git reset HEAD
# 撤销上一次 git commit, 但不删除文件
git reset --soft HEAD^

# 可以通过如下命令进行代码合并【注：pull=fetch+merge]
git pull --rebase origin master

git config --global credential.helper store
# 查看节点树
git log --oneline --graph --decorate --all

# 这个命令把分支"branchname"合并到了当前分支里面。
git merge branchname

#git 删除远程分支
git push origin :br

# 移除远程仓库
git remote rm origin

# 查看连接的远程仓库
git remote -v

# 添加一个远程仓库连接
git remote add origin https://github.com/aBadString/git-test.git

# 修改远程仓库地址
remote set-url gitlab http://192.168.1.100:8443/aBadString/aBadString-Notes.git

# 图状显示提交日志
git log --oneline --graph --decorate --all
```

**【当要提交】**

```bash
# 先切换到主分支
git checkout master

# 拉取远程仓库的代码
git pull origin master

# 把 SongDev 分支合并到 master
git merge SongDev

# 删除 本地 SongDev 分支
git branch -d SongDev
# 删除 远程 SongDev 分支  (origin 后面有空格)
git push origin :SongDev

# 建立新的 SongDev 继续开发
git branch SongDev
```


## 1.3. Git Commit message 编写指南

> 参考: http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html

当我们提交代码的时候, 必须要填写 Commit message (提交说明). 

```bash
git commit -m "hello world"
```

Commit message 包括三个部分：
- Header
- Body
- Footer

```
<type>(<scope>): <subject>
// 空一行
<body>
// 空一行
<footer>
```

### 1.3.1. Header 包括三部分
- type: 必须, 指明提交类型
- scope: 可选, 说明 commit 影响的范围, 比如数据层、控制层、视图层等等, 视项目不同而不同
- subject: 必须, 对提交的简短描述

type 的类型有以下7种:
- feat：新功能（feature）
- fix：修补 bug
- docs：文档（documentation）
- style： 格式（不影响代码运行的变动）
- refactor：重构（即不是新增功能，也不是修改bug的代码变动）
- test：增加测试
- chore：构建过程或辅助工具的变动


## 1.4. Git 开发模式

### 1.4.1. 分支模式
- master 永远代表最新发布版本，和线上运行的一一对应
- **开发新功能**：如果要开发一个新的 feature ，必须从 master 上拉出一条新的 feature 分支，这个分支称为一个变更。
- **功能合并与测试**：假如现在有两个 feature 开发完成后，需要集成，不可以直接合并到 master 分支上。而是拉出一条 release 分支，把两个 feature 分支依次合并过来，然后这条 release 分支要被送去测试。
- 如果测试不通过，则需要回到有问题的 feature 分支上去修改，**不可以在 release 分支上修改**。

### 1.4.2. Git-flow 模式
一条 master，一条 development，如果需要还可以在 development 上拉出 feature

### 1.4.3. 主干模式
只有一条 master，相当于 development 分支的作用。


## 1.5. 配置 GitHub 的 SSH 密钥

生成一个SSH keys

```
ssh-keygen -t rsa -C "lengjsong@outlook.com"
```

然后会出现:

```
Generating public/private rsa key pair.
Enter file in which to save the key (/c/Users/aBadString/.ssh/id_rsa):
```

就是让你输入SSH keys要保存在哪里,一般不用改,就直接回车就好了.

```
Created directory '/c/Users/aBadString/.ssh'.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
```

输入两次密码之后，就会生成 key（不想输入密码直接回车即可）

```
Your identification has been saved in /c/Users/aBadString/.ssh/id_rsa.
Your public key has been saved in /c/Users/aBadString/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:+GnYA2zlkbeoLLpkhAvBYiawGD58DRXNciTRMnwUMws lengjsong@outlook.com
The key's randomart image is:
+---[RSA 2048]----+
|o  .oEO*.        |
|*o  o=o*+.       |
|*B . .*.+ .      |
|=oo  . + + .     |
|o .   = S .      |
|.o   o * .       |
|. o . + *        |
| o . . . .       |
|  o.             |
+----[SHA256]-----+
```

然后来到 GitHub 网站。点击一个储存库的 setting ---> Deploy keys ---> Add deploy keys：
将id_rsa.pub文件内容填入
![image-20200312224657261](../images/git/image-20200312224657261.png)

测试连接，回到 git bash 执行

```
ssh -T git@github.com
```

回答 yes，并出现下面信息则表示链接上了。

![image-20200312225017231](../images/git/image-20200312225017231.png)

设置一下全局的 username 和 email
```
git config --global user.name "aBadString"
git config --global user.email "lengjsong@outlook.com"
```

创建一个本地仓库
```
mkdir aBadString.github.io
cd aBadString.github.io
```
```
git init
```

创建一个 README.md 文件
```
echo "# aBadString.github.io" >> README.md
```

将 README.md 文件添加到暂存库
```
git add README.md
```

提交
```
git commit -m "first commit"
```

将本地仓库关联远程GitHub仓库地址
```
git remote add origin git@github.com:aBadString/aBadString.github.io.git
```

推送所以本地提交到远程仓库
```
git push -u origin master
```

浏览器访问地址 ```https://abadstring.github.io/``


## 1.6. 配置备份仓库

1. **创建备份仓库 repo_bak**
首先在备份磁盘合适位置新建一个 git 仓库
```bash
git init --bare
# 必须添加 --bare 参数，表示仅仅建立一个空的版本库。
# 版本库仅保存版本文件，不会保存工作区文件
```
生成的目录结构如下。和普通git仓库不同的是，版本库的根目录下是普通仓库的.git文件夹中的内容。
```
$ ls
E:\aBadString-Notes
    -- hooks/
    -- info/
    -- objects/
    -- refs/
    -- config
    -- description
    -- HEAD
```

2. **配置源仓库repo_src 和 备份仓库 repo_bak 的连接**
回到源仓库，添加一个 remote 即可
```bash
git remote add bak E:/aBadString-Notes
# 推送代码
git push bak
```
这样 repo_bak 仓库中就更新了 repo_src 仓库的所有修改记录。
虽然不能直接查看文件，但是可以通过克隆仓库的方式，还原所有文件。
```bash
git clone E:/aBadString-Notes
```

克隆之后仓库内容
```bash
$ ls -a
./          .out/             02_JavaScript核心基础/  10_起源引擎/
../         .vscode/          03_数据库与中间件基础/  11_开发手册/
.git/       _config.yml       04_计算机基础理论/      images/
.gitignore  01_Java核心基础/  05_软件工程/            README.md
```


## 1.7. GitLab

### 1.7.1. Docker 安装

> 前置要求：
> - yaml
> - [OpenSSL生成数字证书](https://www.cnblogs.com/f-ck-need-u/p/7113610.html#blogopensslreq)
> - Ununtu
> - Docker
> 
> - [YAML中多行字符串的配置方法](https://www.cnblogs.com/didispace/p/12524194.html)
> - [docker-compose up命令](https://blog.csdn.net/benben_2015/article/details/85330329)：自动完成包括构建镜像，创建服务，启动服务，并关联服务相关容器的一系列操作
> - [docker-compose.yml的使用](https://www.cnblogs.com/ray-mmss/p/10868754.html)
> - [docker compose 用法](https://www.cnblogs.com/niceshot/p/13875831.html)
> 
> 参考：https://zhuanlan.zhihu.com/p/49499229

1. 先创建好 docker-compose 文件的目录结构
```shell
# -p 确保父目录存在，如不存在则创建一个
> mkdir -p gitlab/config
> tree gitlab
gitlab
└── config
```

2. gitlab 目录下创建 docker-compose.yml 文件，内容如下：
```yml
gitlab:
    # 镜像名称/镜像ID（来自 docker search gitlab 查询的结果）
    image: gitlab/gitlab-ce
    # 容器名称
    container_name: gitlab
    # --restart=always : 开机自启动
    restart: always
    hostname: '192.168.1.100'
    # 端口映射（主机端口:容器内端口）
    ports:
        - 8443:8443
    environment:
        # 字符串可以被折成多行，每一行被转化为一个空格
        # 为了保留换行可以使用 \n换行，或者使用 |、|+、|-
        #   |：文中自动换行 + 文末新增一空行
        #   |+：文中自动换行 + 文末新增两空行
        #   |-：文中自动换行 + 文末不新增行
        GITLAB_OMNIBUS_CONFIG: |
            external_url 'https://192.168.1.100:8443'
            nginx['redirect_http_to_https'] = true
            letsencrypt['enable'] = false
            nginx['ssl_certificate'] = "/etc/gitlab/nginx.pem"
            nginx['ssl_certificate_key'] = "/etc/gitlab/nginx.key"
        # Add any other gitlab.rb configuration here, each on its own line
    # 挂载目录（主机目录:容器内目录）
    volumes:
        # - 是 yaml 语法中的数组表示法
        - ./data:/var/opt/gitlab  # 数据目录，保存所以的版本库。如需备份，在主机下拷走该文件夹即可
        - ./logs:/var/log/gitlab  # 日志目录
        - ./config:/etc/gitlab    # 配置目录，下一步的证书和私钥存储在此
```
- 注意 Linux(\n) 和 Windows(\r\n) 换行符号之间是不一样的。
- 怕 yaml 写错的话，这里有一个 [YML在线编辑(校验)器](https://www.bejson.com/validators/yaml_editor/)

3. 新建自签名的证书
```shell
openssl req -new -x509 -days 36500 -nodes -out config/nginx.pem -keyout config/nginx.key -subj "/C=US/CN=gitlab/O=gitlab.com"
```

`req`：
`-new`：表示新生成一个新的证书请求文件
`-x509`：表示生成一个**自签署证书**
`-days n`：指定自签名证书的有效期限，默认30天，需要和"-x509"一起使用。
`-nodes`：禁止对私钥文件加密
`-out filename`：证书的输出文件
`-keyout filename`：指定自动创建私钥时私钥的存放位置
`-subj args`：替换或自定义证书请求时需要输入的信息，并输出修改后的请求信息。args的格式为 `/type0=value0/type1=value1...`。

[openssl req选项](https://www.cnblogs.com/f-ck-need-u/p/7113610.html#blogopensslreq)
```
openssl req [-new] [-newkey rsa:bits] [-verify] [-x509] [-in filename] [-out filename] [-key filename] [-passin arg] [-passout arg] 
[-keyout filename] [-pubkey] [-nodes] [-[dgst]] [-config filename] [-subj arg] [-days n] [-set_serial n] [-extensions section]
[-reqexts section] [-utf8] [-nameopt] [-reqopt] [-subject] [-subj arg] [-text] [-noout] [-batch] [-verbose]
 
选项说明：
-new        ：创建一个证书请求文件，会交互式提醒输入一些信息，这些交互选项以及交互选项信息的长度值以及其他一些扩展属性在配置文件(默认为
            ：openssl.cnf，还有些辅助配置文件)中指定了默认值。如果没有指定"-key"选项，则会自动生成一个RSA私钥，该私钥的生成位置
            ：也在openssl.cnf中指定了。如果指定了-x509选项，则表示创建的是自签署证书文件，而非证书请求文件
-newkey args：类似于"-new"选项，创建一个新的证书请求，并创建私钥。args的格式是"rsa:bits"(其他加密算法请查看man)，其中bits
            ：是rsa密钥的长度，如果bits省略了(即-newkey rsa)，则长度根据配置文件中default_bits指令的值作为默认长度，默认该值为2048
            ：如果指定了-x509选项，则表示创建的是自签署证书文件，而非证书请求文件
-nodes      ：默认情况下，openssl req自动创建私钥时都要求加密并提示输入加密密码，指定该选项后则禁止对私钥文件加密
-key filename    ：指定私钥的输入文件，创建证书请求时需要
-keyout filename ：指定自动创建私钥时私钥的存放位置，若未指定该选项，则使用配置文件中default_keyfile指定的值，默认该值为privkey.pem
-[dgst]          ：指定对创建请求时提供的申请者信息进行数字签名时的单向加密算法，如-md5/-sha1/-sha512等，
                 ：若未指定则默认使用配置文件中default_md指定的值
-verify       ：对证书请求文件进行数字签名验证
-x509         ：指定该选项时，将生成一个自签署证书，而不是创建证书请求。一般用于测试或者为根CA创建自签名证书
-days n       ：指定自签名证书的有效期限，默认30天，需要和"-x509"一起使用。
              ：注意是自签名证书期限，而非请求的证书期限，因为证书的有效期是颁发者指定的，证书请求者指定有效期是没有意义的，
              ：配置文件中的default_days指定了请求证书的有效期限，默认365天
-set_serial n ：指定生成自签名证书时的证书序列号，该序列号将写入配置文件中serial指定的文件中，这样就不需要手动更新该序列号文件
              ：支持数值和16进制值(0x开头)，虽然也支持负数，但不建议
-in filename  ：指定证书请求文件filename。注意，创建证书请求文件时是不需要指定该选项的
-out filename ：证书请求或自签署证书的输出文件，也可以是其他内容的输出文件，不指定时默认stdout
-subj args    ：替换或自定义证书请求时需要输入的信息，并输出修改后的请求信息。args的格式为"/type0=value0/type1=value1..."，
              ：如果value为空，则表示使用配置文件中指定的默认值，如果value值为"."，则表示该项留空。其中可识别type(man req)有：
              ：C是Country、ST是state、L是localcity、O是Organization、OU是Organization Unit、CN是common name等
 
【输出内容选项：】
-text         ：以文本格式打印证书请求
-noout        ：不输出部分信息
-subject      ：输出证书请求文件中的subject(如果指定了x509，则打印证书中的subject)
-pubkey       ：输出证书请求文件中的公钥

【配置文件项和杂项：】
-passin arg      ：传递解密密码
-passout arg     ：指定加密输出文件时的密码
-config filename ：指定req的配置文件，指定后将忽略所有的其他配置文件。如果不指定则默认使用/etc/pki/tls/openssl.cnf中req段落的值
-batch           ：非交互模式，直接从配置文件(默认/etc/pki/tls/openssl.cnf)中读取证书请求所需字段信息。但若不指定"-key"时，仍会询问key
-verbose         ：显示操作执行的详细信息
```

4. 下载并启动 GitLab 容器
完成以上文件后的目录结构
```
gitlab
├── config
│   ├── nginx.key  私钥
│   └── nginx.pem  证书
└── docker-compose.yml
```
在 `docker-compose.yml` 文件同一目录下执行
```shell
docker-compose up
# docker-compose up -d 可以以后台detach模式去执行
```

- 如果没有此命令，可以执行下面两条任意一条命令进行安装：
```shell
snap install docker          # version 19.03.11, or
apt  install docker-compose  # version 1.25.0-1
```

- 如果下载太慢，可以先将镜像拉取到本地（不知为何 docker-compose 并不会从配置的国内镜像仓库拉去镜像）
```shell
 docker pull gitlab/gitlab-ce
```

- 如果还是下载不下来，可以改用国内镜像+中文版GitLab。
docker-compose.yml 文件的容器镜像修改为如下：
```yaml
image: 'registry.cn-hangzhou.aliyuncs.com/lab99/gitlab-ce-zh:latest'
```

**【遇到异常】**
undefined method `[]=' for nil:NilClass
异常表现，GitLab 服务不断重启。日志如下：
```log
================================================================================
Recipe Compile Error in /opt/gitlab/embedded/cookbooks/cache/cookbooks/gitlab/recipes/default.rb
================================================================================
NoMethodError
-------------
undefined method `[]=' for nil:NilClass
Cookbook Trace:
---------------
  /opt/gitlab/embedded/cookbooks/cache/cookbooks/gitlab/recipes/default.rb:35:in `from_file'
Relevant File Content:
----------------------
/opt/gitlab/embedded/cookbooks/cache/cookbooks/gitlab/recipes/default.rb:
 28:    group "root"
 29:    mode "0775"
 30:    action :nothing
 31:  end.run_action(:create)
 32:
 33:  Gitlab[:node] = node
 34:  if File.exists?("/assets/gitlab.rb")
 35>>   Gitlab.from_file("/assets/gitlab.rb")
 36:  end
 37:  node.consume_attributes(Gitlab.generate_config(node['fqdn']))
 38:
 39:  if File.exists?("/var/opt/gitlab/bootstrapped")
 40:        node.set['gitlab']['bootstrap']['enable'] = false
 41:  end
 42:
 43:  directory "/var/opt/gitlab" do
 44:    owner "root"
```

问题出在：docker-compose.yml 文件的 GITLAB_OMNIBUS_CONFIG 参数的书写规则错误，由于实在没有找到正确的书写方式，只好改为一下：
```yaml
gitlab:
    gitlab-ce-zh:latest'
    container_name: gitlab
    restart: always
    hostname: '192.168.1.100'
    ports:
        - 8443:8443
    environment:
        GITLAB_OMNIBUS_CONFIG: external_url 'http://192.168.1.100:8443'
    volumes:
        - ./data:/var/opt/gitlab
        - ./logs:/var/log/gitlab
        - ./config:/etc/gitlab
```
```diff
gitlab:
-   image: gitlab/gitlab-ce
+   image: 'registry.cn-hangzhou.aliyuncs.com/lab99/gitlab-ce-zh:latest'
    container_name: gitlab
    restart: always
    hostname: '192.168.1.100'
    ports:
        - 8443:8443
    environment:
-       GITLAB_OMNIBUS_CONFIG: |
-           external_url 'https://192.168.1.100:8443'
-           nginx['redirect_http_to_https'] = true
-           letsencrypt['enable'] = false
-           nginx['ssl_certificate'] = "/etc/gitlab/nginx.pem"
-           nginx['ssl_certificate_key'] = "/etc/gitlab/nginx.key"
+       GITLAB_OMNIBUS_CONFIG: external_url 'http://192.168.1.100:8443'
    volumes:
        - ./data:/var/opt/gitlab
        - ./logs:/var/log/gitlab
        - ./config:/etc/gitlab
```

5. 浏览器访问 http://192.168.1.100:8443

初始化root用户的密码
![](../images/git/初始化root用户的密码.png)

6. 创建一个新的普通账户
![](../images/git/注册新用户.png)
修改个人资料，[添加SSH密钥](./07_开发工具.md/#12-配置-github-的-ssh-密钥)
用户的存储库在 ./data/git-data/repositories/用户名/ 下。

### 1.7.2. 备份

首先必须保证两个 GitLab 版本一致。

1. 进入容器目录
```shell
docker exec -it GitLab容器ID /bin/bash
```

2. 执行备份
```shell
# 执行备份
gitlab-rake gitlab:backup:create RAILS_ENV=production
# 退出容器
exit
# 查看备份文件
ls gitlab/data/backups/
1608802804_gitlab_backup.tar
```

3. 把文件拷贝到新的服务器上的 GitLab 对应位置
```shell
scp gitlab/data/backups/1608802804_gitlab_backup.tar root@new.abadstring.me:/root/gitlab/data/backups
```

4. 在新服务器上进入 GitLab 容器并执行恢复
注意：恢复是会先删除新服务器上所有gitlab数据的
```shell
# 进入容器
docker exec -it GitLab容器ID /bin/bash
# 提权, Gitlab恢复操作使用的用户是git
chown -R git.git /var/opt/gitlab/backups/
# 执行恢复
gitlab-rake gitlab:backup:restore RAILS_ENV=production BACKUP=1608802804
# 退出容器
exit
```


**gitlab访问项目时报500 OpenSSL::Cipher::CipherError (bad decrypt)**
```shell
# 进入容器
docker exec -it GitLab容器ID /bin/bash

sudo gitlab-rails runner "Project.where.not(import_url: nil).each { |p| p.import_data.destroy if p.import_data }"
```
> 是gitlab数据迁移时的一个缺陷。解决方法：
> 1、覆盖原来gitlab的 db_key_base 到新的gitlab 
> db_key_base  位置在 /etc/gitlab/gitlab-secrets.json  
> 2、EE版本执行
> sudo gitlab-rails runner "Project.where(mirror: false).where.not(import_url: nil).each { |p| p.import_data.> destroy if p.import_data }"
> CE版本执行
> sudo gitlab-rails runner "Project.where.not(import_url: nil).each { |p| p.import_data.destroy if p.import_data }"
> 
> 参考https://gitlab.com/gitlab-org/gitlab-ce/issues/17873

# 2. Maven

## 2.1. 需要做的配置

1、修改本地仓库地址
```xml
<localRepository>D:/Users/aBadString/.m2/repository</localRepository>
```

2、给maven 的settings.xml配置文件的proﬁles标签添加
```xml
<profile>
    <id>jdk‐1.8</id>
    <activation>
        <activeByDefault>true</activeByDefault>
        <jdk>1.8</jdk>
    </activation>
    <properties>
        <maven.compiler.source>1.8</maven.compiler.source>
        <maven.compiler.target>1.8</maven.compiler.target>
        <maven.compiler.compilerVersion>1.8</maven.compiler.compilerVersion>
    </properties>
</profile>
```

3、更换阿里云镜像：在maven的conf文件加下的setting.xml文件中找到```<mirrors></mirrors>```标签
在这个标签中加入阿里云镜像即可
```xml
<mirror>
  <id>alimaven</id>
  <mirrorOf>central</mirrorOf>
  <name>aliyun maven</name>
  <url>http://maven.aliyun.com/nexus/content/repositories/central/</url>
</mirror>
```


## 2.2. Maven 简介

### 2.2.1. 约定配置

| 目录 | 作用 |
| :-- | :---: |
| ${root} | 项目根目录, pom.xml文件存放在根目录下 |
| ${root}/src/main/java | Java 源代码 |   
| ${root}/src/main/resources | 资源文件 |
| ${root}/src/test/java | 测试代码 |
| ${root}/src/test/resources | 测试资源 |
| ${root}/target/classes | Java源代码 class文件 |
| ${root}/target/test-classes | 测试代码 class文件 |

```
.
└── src
    ├── main
        ├── java        // Java 源代码目录
        ├── resources   // 资源文件目录
        ├── webapp      // Web 资源文件目录
    ├── test
        ├── java        // 测试代码目录
        ├── resources   // 测试资源目录
├── target
    ├── classes         //  Java源代码 class文件
    ├── test-classes       // 测试代码 class文件
```

### 2.2.2. POM (Project Object Model 项目对象模型)

pom.xml 文件中可以配置的
- 项目依赖 `dependencies`
- 插件 `plugins`
- 执行目标
- 项目构建 `profile`
- 项目版本
- 项目开发者列表
- 相关邮件列表信息

一个基本的 pom.xml 文件必备要素: project, modelVersion, groupId, artifactId, version
```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    
    <!-- 模型版本 -->
    <modelVersion>4.0.0</modelVersion>
    <!-- 组织唯一ID -->
    <groupId>priv.abadstring</groupId>
    <!-- 项目ID -->
    <artifactId>mavendemo</artifactId>
    <!-- 版本号 -->
    <version>1.0.0-20w21</version>
</project>
```

**[POM 标签全解](https://www.runoob.com/maven/maven-pom.html)**
```xml
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd">
    <!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 
        version。 -->
    <parent>
        <!--被继承的父项目的构件标识符 -->
        <artifactId />
        <!--被继承的父项目的全球唯一标识符 -->
        <groupId />
        <!--被继承的父项目的版本 -->
        <version />
        <!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 
            目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 -->
        <relativePath />
    </parent>
    <!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 -->
    <modelVersion>4.0.0</modelVersion>
    <!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app -->
    <groupId>asia.banseon</groupId>
    <!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 
        特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 -->
    <artifactId>banseon-maven2</artifactId>
    <!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 -->
    <packaging>jar</packaging>
    <!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 -->
    <version>1.0-SNAPSHOT</version>
    <!--项目的名称, Maven产生的文档用 -->
    <name>banseon-maven</name>
    <!--项目主页的URL, Maven产生的文档用 -->
    <url>http://www.baidu.com/banseon</url>
    <!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 
        签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 -->
    <description>A maven project to study maven.</description>
    <!--描述了这个项目构建环境中的前提条件。 -->
    <prerequisites>
        <!--构建该项目或使用该插件所需要的Maven的最低版本 -->
        <maven />
    </prerequisites>
    <!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira -->
    <issueManagement>
        <!--问题管理系统（例如jira）的名字， -->
        <system>jira</system>
        <!--该项目使用的问题管理系统的URL -->
        <url>http://jira.baidu.com/banseon</url>
    </issueManagement>
    <!--项目持续集成信息 -->
    <ciManagement>
        <!--持续集成系统的名字，例如continuum -->
        <system />
        <!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 -->
        <url />
        <!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） -->
        <notifiers>
            <!--配置一种方式，当构建中断时，以该方式通知用户/开发者 -->
            <notifier>
                <!--传送通知的途径 -->
                <type />
                <!--发生错误时是否通知 -->
                <sendOnError />
                <!--构建失败时是否通知 -->
                <sendOnFailure />
                <!--构建成功时是否通知 -->
                <sendOnSuccess />
                <!--发生警告时是否通知 -->
                <sendOnWarning />
                <!--不赞成使用。通知发送到哪里 -->
                <address />
                <!--扩展配置项 -->
                <configuration />
            </notifier>
        </notifiers>
    </ciManagement>
    <!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 -->
    <inceptionYear />
    <!--项目相关邮件列表信息 -->
    <mailingLists>
        <!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 -->
        <mailingList>
            <!--邮件的名称 -->
            <name>Demo</name>
            <!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 -->
            <post>banseon@126.com</post>
            <!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 -->
            <subscribe>banseon@126.com</subscribe>
            <!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 -->
            <unsubscribe>banseon@126.com</unsubscribe>
            <!--你可以浏览邮件信息的URL -->
            <archive>http:/hi.baidu.com/banseon/demo/dev/</archive>
        </mailingList>
    </mailingLists>
    <!--项目开发者列表 -->
    <developers>
        <!--某个项目开发者的信息 -->
        <developer>
            <!--SCM里项目开发者的唯一标识符 -->
            <id>HELLO WORLD</id>
            <!--项目开发者的全名 -->
            <name>banseon</name>
            <!--项目开发者的email -->
            <email>banseon@126.com</email>
            <!--项目开发者的主页的URL -->
            <url />
            <!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 -->
            <roles>
                <role>Project Manager</role>
                <role>Architect</role>
            </roles>
            <!--项目开发者所属组织 -->
            <organization>demo</organization>
            <!--项目开发者所属组织的URL -->
            <organizationUrl>http://hi.baidu.com/banseon</organizationUrl>
            <!--项目开发者属性，如即时消息如何处理等 -->
            <properties>
                <dept>No</dept>
            </properties>
            <!--项目开发者所在时区， -11到12范围内的整数。 -->
            <timezone>-5</timezone>
        </developer>
    </developers>
    <!--项目的其他贡献者列表 -->
    <contributors>
        <!--项目的其他贡献者。参见developers/developer元素 -->
        <contributor>
            <name />
            <email />
            <url />
            <organization />
            <organizationUrl />
            <roles />
            <timezone />
            <properties />
        </contributor>
    </contributors>
    <!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 -->
    <licenses>
        <!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 -->
        <license>
            <!--license用于法律上的名称 -->
            <name>Apache 2</name>
            <!--官方的license正文页面的URL -->
            <url>http://www.baidu.com/banseon/LICENSE-2.0.txt</url>
            <!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 -->
            <distribution>repo</distribution>
            <!--关于license的补充信息 -->
            <comments>A business-friendly OSS license</comments>
        </license>
    </licenses>
    <!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 -->
    <scm>
        <!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 -->
        <connection>
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)
        </connection>
        <!--给开发者使用的，类似connection元素。即该连接不仅仅只读 -->
        <developerConnection>
            scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk
        </developerConnection>
        <!--当前代码的标签，在开发阶段默认为HEAD -->
        <tag />
        <!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 -->
        <url>http://svn.baidu.com/banseon</url>
    </scm>
    <!--描述项目所属组织的各种属性。Maven产生的文档用 -->
    <organization>
        <!--组织的全名 -->
        <name>demo</name>
        <!--组织主页的URL -->
        <url>http://www.baidu.com/banseon</url>
    </organization>
    <!--构建项目需要的信息 -->
    <build>
        <!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 -->
        <sourceDirectory />
        <!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 -->
        <scriptSourceDirectory />
        <!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 -->
        <testSourceDirectory />
        <!--被编译过的应用程序class文件存放的目录。 -->
        <outputDirectory />
        <!--被编译过的测试class文件存放的目录。 -->
        <testOutputDirectory />
        <!--使用来自该项目的一系列构建扩展 -->
        <extensions>
            <!--描述使用到的构建扩展。 -->
            <extension>
                <!--构建扩展的groupId -->
                <groupId />
                <!--构建扩展的artifactId -->
                <artifactId />
                <!--构建扩展的版本 -->
                <version />
            </extension>
        </extensions>
        <!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 -->
        <defaultGoal />
        <!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 -->
        <resources>
            <!--这个元素描述了项目相关或测试相关的所有资源路径 -->
            <resource>
                <!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 
                    子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 -->
                <targetPath />
                <!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 -->
                <filtering />
                <!--描述存放资源的目录，该路径相对POM路径 -->
                <directory />
                <!--包含的模式列表，例如**/*.xml. -->
                <includes />
                <!--排除的模式列表，例如**/*.xml -->
                <excludes />
            </resource>
        </resources>
        <!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 -->
        <testResources>
            <!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 -->
            <testResource>
                <targetPath />
                <filtering />
                <directory />
                <includes />
                <excludes />
            </testResource>
        </testResources>
        <!--构建产生的所有文件存放的目录 -->
        <directory />
        <!--产生的构件的文件名，默认值是${artifactId}-${version}。 -->
        <finalName />
        <!--当filtering开关打开时，使用到的过滤器属性文件列表 -->
        <filters />
        <!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 -->
        <pluginManagement>
            <!--使用的插件列表 。 -->
            <plugins>
                <!--plugin元素包含描述插件所需要的信息。 -->
                <plugin>
                    <!--插件在仓库里的group ID -->
                    <groupId />
                    <!--插件在仓库里的artifact ID -->
                    <artifactId />
                    <!--被使用的插件的版本（或版本范围） -->
                    <version />
                    <!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 -->
                    <extensions />
                    <!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 -->
                    <executions>
                        <!--execution元素包含了插件执行需要的信息 -->
                        <execution>
                            <!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 -->
                            <id />
                            <!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 -->
                            <phase />
                            <!--配置的执行目标 -->
                            <goals />
                            <!--配置是否被传播到子POM -->
                            <inherited />
                            <!--作为DOM对象的配置 -->
                            <configuration />
                        </execution>
                    </executions>
                    <!--项目引入插件所需要的额外依赖 -->
                    <dependencies>
                        <!--参见dependencies/dependency元素 -->
                        <dependency>
                            ......
                        </dependency>
                    </dependencies>
                    <!--任何配置是否被传播到子项目 -->
                    <inherited />
                    <!--作为DOM对象的配置 -->
                    <configuration />
                </plugin>
            </plugins>
        </pluginManagement>
        <!--使用的插件列表 -->
        <plugins>
            <!--参见build/pluginManagement/plugins/plugin元素 -->
            <plugin>
                <groupId />
                <artifactId />
                <version />
                <extensions />
                <executions>
                    <execution>
                        <id />
                        <phase />
                        <goals />
                        <inherited />
                        <configuration />
                    </execution>
                </executions>
                <dependencies>
                    <!--参见dependencies/dependency元素 -->
                    <dependency>
                        ......
                    </dependency>
                </dependencies>
                <goals />
                <inherited />
                <configuration />
            </plugin>
        </plugins>
    </build>
    <!--在列的项目构建profile，如果被激活，会修改构建处理 -->
    <profiles>
        <!--根据环境参数或命令行参数激活某个构建处理 -->
        <profile>
            <!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 -->
            <id />
            <!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 -->
            <activation>
                <!--profile默认是否激活的标志 -->
                <activeByDefault />
                <!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 -->
                <jdk />
                <!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 -->
                <os>
                    <!--激活profile的操作系统的名字 -->
                    <name>Windows XP</name>
                    <!--激活profile的操作系统所属家族(如 'windows') -->
                    <family>Windows</family>
                    <!--激活profile的操作系统体系结构 -->
                    <arch>x86</arch>
                    <!--激活profile的操作系统版本 -->
                    <version>5.1.2600</version>
                </os>
                <!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 -->
                <property>
                    <!--激活profile的属性的名称 -->
                    <name>mavenVersion</name>
                    <!--激活profile的属性的值 -->
                    <value>2.0.3</value>
                </property>
                <!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 -->
                <file>
                    <!--如果指定的文件存在，则激活profile。 -->
                    <exists>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/
                    </exists>
                    <!--如果指定的文件不存在，则激活profile。 -->
                    <missing>/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/
                    </missing>
                </file>
            </activation>
            <!--构建项目所需要的信息。参见build元素 -->
            <build>
                <defaultGoal />
                <resources>
                    <resource>
                        <targetPath />
                        <filtering />
                        <directory />
                        <includes />
                        <excludes />
                    </resource>
                </resources>
                <testResources>
                    <testResource>
                        <targetPath />
                        <filtering />
                        <directory />
                        <includes />
                        <excludes />
                    </testResource>
                </testResources>
                <directory />
                <finalName />
                <filters />
                <pluginManagement>
                    <plugins>
                        <!--参见build/pluginManagement/plugins/plugin元素 -->
                        <plugin>
                            <groupId />
                            <artifactId />
                            <version />
                            <extensions />
                            <executions>
                                <execution>
                                    <id />
                                    <phase />
                                    <goals />
                                    <inherited />
                                    <configuration />
                                </execution>
                            </executions>
                            <dependencies>
                                <!--参见dependencies/dependency元素 -->
                                <dependency>
                                    ......
                                </dependency>
                            </dependencies>
                            <goals />
                            <inherited />
                            <configuration />
                        </plugin>
                    </plugins>
                </pluginManagement>
                <plugins>
                    <!--参见build/pluginManagement/plugins/plugin元素 -->
                    <plugin>
                        <groupId />
                        <artifactId />
                        <version />
                        <extensions />
                        <executions>
                            <execution>
                                <id />
                                <phase />
                                <goals />
                                <inherited />
                                <configuration />
                            </execution>
                        </executions>
                        <dependencies>
                            <!--参见dependencies/dependency元素 -->
                            <dependency>
                                ......
                            </dependency>
                        </dependencies>
                        <goals />
                        <inherited />
                        <configuration />
                    </plugin>
                </plugins>
            </build>
            <!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 -->
            <modules />
            <!--发现依赖和扩展的远程仓库列表。 -->
            <repositories>
                <!--参见repositories/repository元素 -->
                <repository>
                    <releases>
                        <enabled />
                        <updatePolicy />
                        <checksumPolicy />
                    </releases>
                    <snapshots>
                        <enabled />
                        <updatePolicy />
                        <checksumPolicy />
                    </snapshots>
                    <id />
                    <name />
                    <url />
                    <layout />
                </repository>
            </repositories>
            <!--发现插件的远程仓库列表，这些插件用于构建和报表 -->
            <pluginRepositories>
                <!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 -->
                <pluginRepository>
                    <releases>
                        <enabled />
                        <updatePolicy />
                        <checksumPolicy />
                    </releases>
                    <snapshots>
                        <enabled />
                        <updatePolicy />
                        <checksumPolicy />
                    </snapshots>
                    <id />
                    <name />
                    <url />
                    <layout />
                </pluginRepository>
            </pluginRepositories>
            <!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 -->
            <dependencies>
                <!--参见dependencies/dependency元素 -->
                <dependency>
                    ......
                </dependency>
            </dependencies>
            <!--不赞成使用. 现在Maven忽略该元素. -->
            <reports />
            <!--该元素包括使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 -->
            <reporting>
                ......
            </reporting>
            <!--参见dependencyManagement元素 -->
            <dependencyManagement>
                <dependencies>
                    <!--参见dependencies/dependency元素 -->
                    <dependency>
                        ......
                    </dependency>
                </dependencies>
            </dependencyManagement>
            <!--参见distributionManagement元素 -->
            <distributionManagement>
                ......
            </distributionManagement>
            <!--参见properties元素 -->
            <properties />
        </profile>
    </profiles>
    <!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 -->
    <modules />
    <!--发现依赖和扩展的远程仓库列表。 -->
    <repositories>
        <!--包含需要连接到远程仓库的信息 -->
        <repository>
            <!--如何处理远程仓库里发布版本的下载 -->
            <releases>
                <!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 -->
                <enabled />
                <!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 -->
                <updatePolicy />
                <!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 -->
                <checksumPolicy />
            </releases>
            <!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 
                策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 -->
            <snapshots>
                <enabled />
                <updatePolicy />
                <checksumPolicy />
            </snapshots>
            <!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 -->
            <id>banseon-repository-proxy</id>
            <!--远程仓库名称 -->
            <name>banseon-repository-proxy</name>
            <!--远程仓库URL，按protocol://hostname/path形式 -->
            <url>http://192.168.1.169:9999/repository/</url>
            <!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 
                而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 -->
            <layout>default</layout>
        </repository>
    </repositories>
    <!--发现插件的远程仓库列表，这些插件用于构建和报表 -->
    <pluginRepositories>
        <!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 -->
        <pluginRepository>
            ......
        </pluginRepository>
    </pluginRepositories>
 
 
    <!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 -->
    <dependencies>
        <dependency>
            <!--依赖的group ID -->
            <groupId>org.apache.maven</groupId>
            <!--依赖的artifact ID -->
            <artifactId>maven-artifact</artifactId>
            <!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 -->
            <version>3.8.1</version>
            <!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 
                尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 -->
            <type>jar</type>
            <!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 
                JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 -->
            <classifier></classifier>
            <!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath 
                - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 
                - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 -->
            <scope>test</scope>
            <!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 -->
            <systemPath></systemPath>
            <!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 -->
            <exclusions>
                <exclusion>
                    <artifactId>spring-core</artifactId>
                    <groupId>org.springframework</groupId>
                </exclusion>
            </exclusions>
            <!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 -->
            <optional>true</optional>
        </dependency>
    </dependencies>
    <!--不赞成使用. 现在Maven忽略该元素. -->
    <reports></reports>
    <!--该元素描述使用报表插件产生报表的规范。当用户执行"mvn site"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 -->
    <reporting>
        <!--true，则，网站不包括默认的报表。这包括"项目信息"菜单中的报表。 -->
        <excludeDefaults />
        <!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 -->
        <outputDirectory />
        <!--使用的报表插件和他们的配置。 -->
        <plugins>
            <!--plugin元素包含描述报表插件需要的信息 -->
            <plugin>
                <!--报表插件在仓库里的group ID -->
                <groupId />
                <!--报表插件在仓库里的artifact ID -->
                <artifactId />
                <!--被使用的报表插件的版本（或版本范围） -->
                <version />
                <!--任何配置是否被传播到子项目 -->
                <inherited />
                <!--报表插件的配置 -->
                <configuration />
                <!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 -->
                <reportSets>
                    <!--表示报表的一个集合，以及产生该集合的配置 -->
                    <reportSet>
                        <!--报表集合的唯一标识符，POM继承时用到 -->
                        <id />
                        <!--产生报表集合时，被使用的报表的配置 -->
                        <configuration />
                        <!--配置是否被继承到子POMs -->
                        <inherited />
                        <!--这个集合里使用到哪些报表 -->
                        <reports />
                    </reportSet>
                </reportSets>
            </plugin>
        </plugins>
    </reporting>
    <!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact 
        ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 -->
    <dependencyManagement>
        <dependencies>
            <!--参见dependencies/dependency元素 -->
            <dependency>
                ......
            </dependency>
        </dependencies>
    </dependencyManagement>
    <!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 -->
    <distributionManagement>
        <!--部署项目产生的构件到远程仓库需要的信息 -->
        <repository>
            <!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 -->
            <uniqueVersion />
            <id>banseon-maven2</id>
            <name>banseon maven2</name>
            <url>file://${basedir}/target/deploy</url>
            <layout />
        </repository>
        <!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 -->
        <snapshotRepository>
            <uniqueVersion />
            <id>banseon-maven2</id>
            <name>Banseon-maven2 Snapshot Repository</name>
            <url>scp://svn.baidu.com/banseon:/usr/local/maven-snapshot</url>
            <layout />
        </snapshotRepository>
        <!--部署项目的网站需要的信息 -->
        <site>
            <!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 -->
            <id>banseon-site</id>
            <!--部署位置的名称 -->
            <name>business api website</name>
            <!--部署位置的URL，按protocol://hostname/path形式 -->
            <url>
                scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web
            </url>
        </site>
        <!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 -->
        <downloadUrl />
        <!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 -->
        <relocation>
            <!--构件新的group ID -->
            <groupId />
            <!--构件新的artifact ID -->
            <artifactId />
            <!--构件新的版本号 -->
            <version />
            <!--显示给用户的，关于移动的额外信息，例如原因。 -->
            <message />
        </relocation>
        <!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 
            Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 -->
        <status />
    </distributionManagement>
    <!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是<name>value</name>。 -->
    <properties />
</project>
```


## 2.3. Maven 命令

### 2.3.1. package、install、deploy的联系与区别

> https://blog.csdn.net/zhaojianting/java/article/details/80324533

仔细查看上面的输出结果截图，可以发现，

mvn clean package 依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等７个阶段。  
mvn clean install 依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install等8个阶段。  
mvn clean deploy  依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy等９个阶段。

由上面的分析可知主要区别如下，  
package 命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库  
install 命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库  
deploy  命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库

## 2.4. 常见问题

**IDEA 中创建 Maven 工程报错：**
> Unable to import maven project: See logs for details

问题出在：
1. Maven 版本：之前使用的是 3.6.3，换成 3.3.9 就行了。https://bbs.csdn.net/topics/394531377
2. Maven 的 running 和 importing 的 jdk 版本不一致，都换成 jdk1.8。https://blog.csdn.net/wangjin890620/article/details/101363943


# 3. Gradle

## 3.1. 安装配置

1. **下载解压，并将 bin 目录加入环境变量中**

2. **配置仓库源**

在 Gradle 根目录中的 init.d 目录下创建一个文件 init.gradle，添加配置：

```groovy
allprojects {
    repositories {
        maven { url "file:///D:/Users/aBadString/.m2/repository" }
        mavenLocal()
        maven { name "aliyun"; url "http://maven.aliyun.com/nexus/content/groups/public" }
        mavenCentral()
    }
}
```

# 4. Docker

## 4.1. Docker 的安装和启动

安装 Docker

```shell
sudo apt install docker.io
```

启动 Docker 服务
```shell
# 启动docker
systemctl start docker 
# 开机启动docker 
systemctl enable docker
```

## 4.2. Docker常用命令

### 4.2.1. 配置Docker 加速

新建文件
```shell
vi /etc/docker/daemon.json
```
并写入以下内容（网易镜像）：
```
{
    "registry-mirrors": ["http://hub-mirror.c.163.com"]
}
```
重启服务
```shell
service docker restart
```

### 4.2.2. 镜像操作

> 镜像网站 https://hub.docker.com/

```shell
# 检索 根据关键字在仓库检索所有镜像
docker search mysql

# 拉取 docker pull 镜像名:tag :tag是可选的，tag表示标签，多为软件的版本，默认是 latest, 最新版本
docker pull mysql:8.0.15

# 列表 查看所有本地镜像
docker images

# 删除 删除指定的本地镜像
docker rmi [image-id] 
```

### 4.2.3. 容器操作

```shell
# 根据镜像创建并启动容器
docker run ‐‐name mytomcat ‐d ‐p 8888:8080 tomcat:latest
# ‐‐name: 容器名字
# -d: 后台运行
# tomcat:latest 镜像
# ‐p 8888:8080: 端口映射, 主机端口:Docker容器端口


# 查看运行中的容器
docker ps

# 查看所有的容器 
docker ps ‐a 

# 停止运行中的容器 
docker stop 容器的id

# 启动容器 
docker start 容器id 

# 删除一个容器 
docker rm 容器id

# 查看容器日志
docker logs 容器id
```


### 4.2.4. 安装 MySQL 和 Tomcat

```shell
# 1、下载 MySQL 镜像
sudo docker pull mysql:8.0.15 

# 2、根据镜像创建并启动 MySQL 容器
sudo docker run ‐p 3306:3306 ‐‐name MySQL ‐e MYSQL_ROOT_PASSWORD=123456 ‐d mysql:8.0.15
# ‐e MYSQL_ROOT_PASSWORD=123456: 指定 root 的密码

# 3、下载 Tomcat 镜像
sudo docker pull tomcat:8.0.52
# 4、根据镜像创建并启动 Tomcat 容器
sudo docker run ‐p 8080:8080 ‐‐name Tomcat --restart=always -v /home/abadstring/tomcat/webapps:/usr/local/tomcat/webapps ‐d tomcat:8.0.52
# -v /home/abadstring/tomcat/webapps:/usr/local/tomcat/webapps
# 挂载目录, 主机目录:容器目录
# --restart=always : 开机自启动
```

如果已经创建好的容器，更改为自启动
```shell
docker update --restart=always <容器名字>
```

将应用的 war 包拷贝到Tomcat容器的webapp下
```shell
docker cp hotel-manage-1.0.0.war ee8a3313b18d:/usr/local/tomcat/webapps

# 进入容器目录看看是否拷贝成功
docker exec -it ee8a3313b18d /bin/bash
ls webapps/
```

### 4.2.5. 配置 Docker 远程连接

1、修改docker配置文件
```
vi /usr/lib/systemd/system/docker.service
```
把`ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock`这一行
修改成`ExecStart=/usr/bin/dockerd   -H tcp://0.0.0.0:2375 -H unix://var/run/docker.sock`

2、运行下面两条命令，使配置生效
```shell
systemctl daemon-reload && service docker restart
```

3、测试连接
```shell
docker -H 192.168.1.100 info
```
浏览器访问：http://192.168.1.100:2375/version

4、IDEA 连接
1. 打开：File | Settings | Build, Execution, Deployment | Docker
2. 添加一个，选择 TCP socket，填写：tcp://192.168.1.100:2375


## 4.3. Dockerfile

### 4.3.1. 使用 Dockerfile 定制镜像

```dockerfile
FROM nginx
RUN echo '这是一个本地构建的nginx镜像' > /usr/share/nginx/html/index.html
```
定制一个 nginx 镜像，构建好的镜像内会有一个 /usr/share/nginx/html/index.html 文件

### 4.3.2. 指令

**FROM**：
定制的镜像都是基于 FROM 的镜像，这里的 nginx 就是定制需要的基础镜像。后续的操作都是基于 nginx。

**RUN**：
用于执行后面跟着的命令行命令。有以下俩种格式：
- Shell 格式 `RUN <命令行命令>`
- Exec 格式 `RUN ["可执行文件", "参数1", "参数2"]` 例如：`RUN ["./test.php", "dev", "offline"]`

**ENV**
设置环境变量，定义了环境变量，那么在后续的指令中，就可以使用这个环境变量。
```dockerfile
ENV <key> <value>
ENV <key1>=<value1> <key2>=<value2> ...
```

**ARG**
构建参数。ARG 设置的环境变量仅对 Dockerfile 内有效，也就是说只有 docker build 的过程中有效，构建好的镜像内不存在此环境变量。
```dockerfile
ARG <参数名>[=<默认值>]
```

**COPY**
复制指令，从上下文目录中复制文件或者目录到容器里指定路径。
```dockerfile
COPY [--chown=<user>:<group>] <源路径1>...  <目标路径>
COPY [--chown=<user>:<group>] ["<源路径1>",...  "<目标路径>"]
```
[--chown=<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。
<源路径>：源文件或者源目录，这里可以是通配符表达式
<目标路径>：容器内的指定路径，该路径不用事先建好，路径不存在的话，会自动创建。

**VOLUME**
定义匿名数据卷。在启动容器时忘记挂载数据卷，会自动挂载到匿名卷。
```dockerfile
VOLUME ["<路径1>", "<路径2>"...]
VOLUME <路径>
```
匿名volume在host机器上的目录路径类似于：`/var/lib/docker/volumes/300c2264cd0acfe862507eedf156eb61c197720f69e7e9a053c87c2182b2e7d8/_data`。

**WORKDIR**
指定工作目录。指定的工作目录，必须是提前创建好的。
```dockerfile
WORKDIR <工作目录路径>
```

### 4.3.3. Docker 镜像制作

#### 4.3.3.1. JRE 镜像

> https://blog.csdn.net/zhuchuanwan/article/details/102957332?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai

1. 下载 JRE并上传给 Linux
- [JRE 清华源下载地址](https://mirrors.tuna.tsinghua.edu.cn/AdoptOpenJDK/8/jre/x64/linux/OpenJDK8U-jre_x64_linux_hotspot_8u275b01.tar.gz)
- 上传文件 `scp .\OpenJDK8U-jre_x64_linux_hotspot_8u275b01.tar.gz abadstring@abadstring.me:~/docker/`
- 解压 `tar -xzvf OpenJDK8U-jre_x64_linux_hotspot_8u275b01.tar.gz`
- 修改解压后的文件夹名字为 jre `mv jdk8u275-b01-jre jre`

2. 删除掉一些信息和许可的文本文件，以及 man 目录
```shell
rm LICENSE release ASSEMBLY_EXCEPTION THIRD_PARTY_README
rm -r man/ # man 查看命令帮助信息
```

3. 创建 Dockerfile 文件
> 使用 alpine 作为基础镜像。alpine是一个轻量级的 Linux，镜像大小 5M 左右
```dockerfile
# 基础镜像: alpine 一个轻量级的 Linux
FROM jeanblanchard/alpine-glibc
# 拷贝宿主机下的 jre/ 目录中的文件 到容器的 /usr/local/jre/ 目录下
COPY jre/ /usr/local/jre/
# 下面两句设置环境变量
ENV JAVA_HOME /usr/local/jre
ENV PATH ${PATH}:${JAVA_HOME}/bin
# 打印 java 版本信息
# CMD ["java", "-version"]
```

目前目录结构:
```shell
./
|-- Dockerfile
|-- jre
```

4. 创建镜像
注意命令后面有一个 . 表示当前目录
abadstring/jre8u275 是即将创建的镜像标签
可以使用 `-f` 指定要使用的 Dockerfile 的路径
```shell
docker build -t abadstring/jre8u275 .
```

可以看见镜像已经创建好了
```shell
docker images
REPOSITORY                  TAG     IMAGE ID      CREATED          SIZE
abadstring/jre8u275         latest  d9d673ceaf3e  11 minutes ago   129MB
jeanblanchard/alpine-glibc  latest  4fad0894f97c  10 days ago      17.7MB
```

# 5. Shell
Bash: Bourne Again Shell

## 5.1. 变量

**定义变量**  
定义变量时，变量名不加美元符号（$，PHP语言中变量需要），如：
```shell
your_name="runoob.com"
```
注意，变量名和等号之间不能有空格。

同时，变量名的命名须遵循如下规则：  
- 命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。
- 中间不能有空格，可以使用下划线（_）。
- 不能使用标点符号。
- 不能使用bash里的关键字（可用help命令查看保留关键字）。

**使用变量**  
使用一个定义过的变量，只要在变量名前面加美元符号即可。  
变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界。


```shell
#!/bin/bash

# 使用变量 $变量名 / ${变量名}
your_name="songwan"
echo $your_name
echo ${your_name}

# 变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：
for skill in Ada Coffe Action Java; do
    echo "I am good at ${skill}Script"
done

# 变量可以被重新赋值
your_name="tom"
echo $your_name
your_name="alibaba"
echo $your_name

# 只读变量
myUrl="https://www.google.com"
readonly myUrl
#myUrl="https://www.runoob.com"

# 删除变量 unset 
# 变量被删除后不能再次使用。unset 命令不能删除只读变量。
runoob="https://www.runoob.com"
unset runoob
echo $runoob

#unset myUrl
```

## 5.2. 字符串

**单引号字符串：**  
单引号里的任何字符都会**原样输出**，单引号字符串中的变量是无效的；  
单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。

**双引号的字符串：**  
双引号里可以有变量  
双引号里可以出现转义字符 \n \"

```shell
your_name="runoob"
# 使用双引号拼接
# "hello, " + $your_name + " !"
# 双引号内 $ 会被转义
greeting="hello, "$your_name" !"
greeting_1="hello, ${your_name} !"
echo $greeting  $greeting_1
# hello, runoob ! hello, runoob !

# 使用单引号拼接 'hello, ' + $your_name + ' !'
greeting_2='hello, '$your_name' !'
greeting_3='hello, ${your_name} !'
echo $greeting_2  $greeting_3
# hello, runoob ! hello, ${your_name} !
```

字符串长度：`${#your_name}`

截取自字符串：`${your_name:1:4}` 从下标为 1 的位置开始(含该位置)往后取 4 个字符 (下标从0开始)


## 5.3. 数组

数组名=(值1 值2 ... 值n)
```shell
array_name=(value0 value1 value2 value3)

# 使用 @ 或 * 符号可以获取数组中的所有元素
echo ${array_name[2]}
echo ${array_name[@]}
echo ${array_name[*]}
# value2
# value0 value1 value2 value3
# value0 value1 value2 value3

# 取得数组元素的个数
length=${#array_name[@]}
echo $length
# 或者
length=${#array_name[*]}
echo $length

# 取得数组单个元素的长度
length=${#array_name[1]}
echo $length
```

## 5.4. 注释

```shell
# 单行注释

:<<EOF
多行注释
多行注释
EOF

# EOF 也可以使用其他符号:
:<<'
多行注释
多行注释
'

:<<!
多行注释
多行注释
!
```

## 5.5. 命令行参数

> https://www.runoob.com/linux/linux-shell-passing-arguments.html

```shell
echo "脚本文件名："$0
echo "第一个参数："$1
echo "第二个参数："$1
echo "第三个参数："$3
echo "参数个数为："$#
echo "脚本运行的当前进程ID号："$$
# 脚本文件名：04_argument.sh
# 第一个参数：1
# 第二个参数：1
# 第三个参数：3
# 参数个数为：3
```

**$* 与 $@ 区别：**  
相同点：都是引用所有参数。  
不同点：只有在【双引号】中体现出来。  
        假设在脚本运行时写了三个参数 1、2、3，，  
        则 "$*" 等价于 "1 2 3"（传递了一个参数）(特殊)，  
        而 "$@" 等价于 "1" "2" "3"（传递了三个参数）。  
       没有【双引号】时，  
        $* 和 $@ 都是传递了三个参数  

## 5.6. 基本运算符

原生bash不支持简单的数学运算，但是可以通过其他命令来实现，例如 awk 和 expr，expr 最常用。  
expr 是一款表达式计算工具，使用它能完成表达式的求值操作。

> https://www.runoob.com/linux/linux-shell-basic-operators.html

# 6. VMWare 虚拟机

## 6.1. 文件
> [怎样让硬盘分区显示整数大小](https://jingyan.baidu.com/article/22a299b51d41d59e19376a90.html)
> [VMware虚拟机文件（后缀）详解](https://www.cnblogs.com/shangpolu/p/7169151.html)

![](../images/VMware虚拟机文件.png)

## 6.2. VMware 虚拟机三种网络模式

> [Vmware虚拟机三种网络模式详解](https://www.cnblogs.com/linjiaxin/p/6476480.html)

1. **Bridged(桥接模式)**
虚拟机就像是局域网中的一独立的主机，直接连接到网关，需要空闲的IP地址，局域网内可以直接互相访问。相当于使用双绞线将虚拟机和网关连接起来。
![Bridged 模式网络结构](http://img.blog.csdn.net/20160408183817187)

2. **Host-only(仅主机模式)**
虚拟机与物理网络是隔绝的，虚拟机和主机、同一主机的虚拟机之间可以通讯。相当于使用双绞线将虚拟机和主机连接起来。使用到网适网络配器 VMware Network Adapter VMnet1。
![Host-only 模式网络结构](http://img.blog.csdn.net/20160408185234834)

3. **NAT(网络地址转换模式)**
网络的拓扑结构和 Host-only 一致，在其基础上增加了**网络地址转换**功能。主机还担任了【主机-虚拟机】网络中的网关角色，虚拟机可以通过主机(网关)访问外部网络。使用到网适网络配器 VMware Network Adapter VMnet8。
![NAT 模式网络结构](http://img.blog.csdn.net/20160408184441387)


# 7. Ubuntu

使用 VMware 安装 Ubuntu 服务器版。
创建虚拟机后，启动虚拟机。  
下载地址: https://cn.ubuntu.com/download

## 7.1. 换源

> https://blog.csdn.net/wangyijieonline/article/details/105360138

查看系统代号
```shell
lsb_release -a
```

上[阿里源](http://archive.ubuntu.com/ubuntu/dists/)看看对应的代号的文件是否存在

先备份一下之前的文件
```shell
sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak
```

进入 VI 编辑器修改下载源文件
```shell
sudo vi /etc/apt/sources.list
```

按 i 进入编辑模式, 把所有的内容都删除, 添加以下内容:
```
deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse

deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse
```

修改完成之后, 按ESC退出编辑模式, 再按 : 进入命令模式, 按 wq! 保存退出  
换源之后执行下面两条命令
```shell
# 更新 ubuntu 系统的apt资源
sudo apt-get update
# 进行 ubuntu 系统与软件更新
sudo apt-get upgrade
```

## 7.2. 设置时区
```shell
timedatectl set-timezone Asia/Shanghai
```
结果：
```shell
date
Fri 02 Oct 2020 02:04:26 PM CST

date -R
Fri, 02 Oct 2020 14:04:34 +0800
```

## 7.3. 安装 SSH

> ssh 错误 ssh: connect to host 192.168.1.106 port 22: Connection refused
> https://blog.csdn.net/bush2582/article/details/18945553

```shell
sudo apt-get install openssh-server
```

从物理机上输入命令即可连接到 ubuntu
```shell
# 连接SSH
ssh 【ip地址】
# 断开连接
logout
```

### 7.3.1. SSH 公钥登录

0. [生成自己的公钥](./07_开发工具.md/#12-配置-github-的-ssh-密钥)

1. 在登录用户 home 目录中新建一个文件 `~/.ssh/authorized_keys`。
并写入自己的公钥文件 id_rsa.pub 的内容
```shell
> cat ~/.ssh/authorized_keys
ssh-rsa .........
```

2. 更改配置文件：vi /etc/ssh/sshd_config，启用 公钥登录
```
PubkeyAuthentication yes # 公钥登录
```

3. 可以使用公钥登录了
```shell
ssh -i ~/.ssh/id_rsa abadstring@192.168.1.100
# 或者
ssh -i id_rsa abadstring@192.168.1.100
```

4. 配合 Windows Terminal 使用

编辑 Windows Terminal 的配置文件 settings.json：
profiles > list 中新加一项（guid 可以使用这个网站生成一个 [GUID 生成器](https://www.guidgen.com/)）
```json
{
    "guid": "{26fe7b8e-8f39-4a6e-94eb-da9bcddf318f}",
    "hidden": false,
    "name": "Ubuntu",
    "commandline": "ssh -i ~/.ssh/id_rsa abadstring@192.168.1.100"
},
```

## 7.4. 修改登录 Banner

1. 边界配置文件 `vi /etc/ssh/sshd_config`，再末尾加上：
```
Banner /etc/ssh/banner
```

2. 创建/etc/ssh/banner文件 `vi /etc/ssh/banner`，并添加 Banner 内容：
```
        ____            _ ____  _        _             
   __ _| __ )  __ _  __| / ___|| |_ _ __(_)_ __   __ _ 
  / _` |  _ \ / _` |/ _` \___ \| __| '__| | '_ \ / _` |
 | (_| | |_) | (_| | (_| |___) | |_| |  | | | | | (_| |
  \__,_|____/ \__,_|\__,_|____/ \__|_|  |_|_| |_|\__, |
                                                 |___/ 
```
[生成字符画](http://patorjk.com/software/taag)

3. 重启sshd服务 `systemctl restart sshd`

4. ssh 登录实施效果
```
> ssh 192.168.1.100
        ____            _ ____  _        _
   __ _| __ )  __ _  __| / ___|| |_ _ __(_)_ __   __ _
  / _` |  _ \ / _` |/ _` \___ \| __| '__| | '_ \ / _` |
 | (_| | |_) | (_| | (_| |___) | |_| |  | | | | | (_| |
  \__,_|____/ \__,_|\__,_|____/ \__|_|  |_|_| |_|\__, |
                                                 |___/
abadstring@192.168.1.100's password:
```

## 7.5. 固定IP地址

### 7.5.1. 虚拟机桥接模式下固定静态 IP 地址

> https://www.cnblogs.com/ubuntuanzhuang/p/13131138.html
> https://blog.csdn.net/sirobot/article/details/107457473
> [个人专属多节点Linux环境打造 · CodeSheep](https://www.bilibili.com/video/BV1bA411b7vs)

1. ==首先在 VM 虚拟机设置 网络适配器 为 桥接模式。==

2. 先备份一下之前的网络配置
> 说明：ubuntu 从 17.10 开始，已放弃在 /etc/network/interfaces 里固定 IP 的配置，即使配置也不会生效，而是改成 netplan 方式 ，配置写在 /etc/netplan/01-netcfg.yaml 或者类似名称的 yaml 文件里
```shell
# 网络配置在这个目录下，是个yaml文件
ls /etc/netplan/
# 备份一下先
sudo cp /etc/netplan/00-installer-config.yaml /etc/netplan/00-installer-config.yaml.bak
```

看看文件内容：
```yml
# This is the network config written by 'subiquity'
network:
  ethernets:
    ens33:
      dhcp4: true
  version: 2
```

3. 修改为
```yml
# This is the network config written by 'subiquity'
network:
  ethernets:
    ens33:
      dhcp4: no                     # 关闭动态分配 IPv4 地址
      addresses: [192.168.1.100/24] # 本机固定 IP 和掩码
      gateway4: 192.168.1.1         # 网关(局域网的路由器 IP)
      nameservers:
        addresses: [192.168.1.1,119.29.29.29]    # DNS 服务器地址 192.168.1.1是局域网内的DNS 119.29.29.29是公网DNS
  version: 2
```
4. 应用新配置 `sudo netplan apply`

注意：
1. 一定要配置公网DNS，不然无法解析域名，不能 ping www.baidu.com。  
DNS 服务器可以到这里找 https://ip.cn/dns.html
2. ping 不通 win10 宿主机？防火墙-入站规则-ICMP 开启 https://blog.csdn.net/wy_bk/article/details/85013933

### 7.5.2. 虚拟机 NAT 模式下固定静态 IP 地址

> 桥接模式一般可以满足虚拟机联网的需求。
> 但是，一方面，虚拟机是直接连接到局域网网关的，也就是说同一局域网内可以直接访问到虚拟机的 Web 服务；
> 另一方面，如果主机断网了，主机和虚拟机之间是不能 ping 通，主机也不能访问虚拟机的 Web 服务的。
> 
> 参考：[VMware虚拟机 NAT模式 配置静态ip](https://blog.csdn.net/xp_lx1/article/details/90691345)

1. 首先将VM 虚拟机设置 网络适配器 改为 NAT模式

2. 在主机(Win 10)上查看 VMware Network Adapter VMnet8 网卡的IP
```shell
> ipconfig

以太网适配器 VMware Network Adapter VMnet8:
  连接特定的 DNS 后缀 . . . . . . . :
  本地链接 IPv6 地址. . . . . . . . : fe80::b5b6:bbd8:a956:9a5f%10
  IPv4 地址 . . . . . . . . . . . . : 192.168.18.1
  子网掩码  . . . . . . . . . . . . : 255.255.255.0
  默认网关. . . . . . . . . . . . . :
```
==**192.168.18.1 这个ip 就是虚拟机(Ubuntu)配置静态 IP 时的网关。**==

3. 修改 Ubuntu 的网络配置文件 `sudo vi /etc/netplan/00-installer-config.yaml`
==**注意：虚拟机IP必须和网关IP处于同一子网中，即网络号一致**==
```diff
# This is the network config written by 'subiquity'
network:
  ethernets:
    ens33:
      dhcp4: no                     # 关闭动态分配 IPv4 地址
-     addresses: [192.168.1.100/24] # 本机固定 IP 和掩码
+     addresses: [192.168.18.100/24] # IP 和子网掩码需要修改，使得网络号和网关保持一致 (此时网络号为 192.168.18.0)
-     gateway4: 192.168.1.1         # 网关(局域网的路由器 IP)
+     gateway4: 192.168.18.1        # 网关修改为第2步查看的 IP
      nameservers:
-       addresses: [192.168.1.1,119.29.29.29]    # DNS 服务器地址 192.168.1.1是局域网内的DNS 119.29.29.29是公网DNS
+       addresses: [192.168.18.1,202.101.224.69,119.29.29.29]
  version: 2
```
最终文件内容：`cat /etc/netplan/00-installer-config.yaml`
```yaml
# This is the network config written by 'subiquity'
network:
  ethernets:
    ens33:
      dhcp4: no
      addresses: [192.168.18.100/24]
      gateway4: 192.168.18.1
      nameservers:
        addresses: [192.168.18.1,202.101.224.69,119.29.29.29]
  version: 2
```

4. 应用新配置 `sudo netplan apply`

5. 查看网关
```shell
route -n
# or
ip route show
```
```shell
> ip route show
default via 192.168.18.1 dev ens33 proto static
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1
192.168.18.0/24 dev ens33 proto kernel scope link src 192.168.18.100
```
可以看到现在网关已经是 192.168.18.1，并且虚拟机的 IP 已经改成 192.168.18.100 了。

到此为止，无论主机(物理机)是否连接网络，主机可以 ping 通虚拟机，可以通过 ssh 登录到虚拟机，也可以访问虚拟机的 Web 服务。局域网内的主机无法之间访问到虚拟机的 Web 服务。
**但是虚拟机无法 ping 通主机和 www.baidu.com**。

#### 7.5.2.1. 解决虚拟机无法连接注解和外部网络的问题

首先我们明确一下虚拟机 NAT 模式下的网络拓扑结构：
![NAT 模式网络结构](http://img.blog.csdn.net/20160408184441387)
> 在 NAT 模式中，主机网卡直接与虚拟 NAT 设备相连，然后虚拟 NAT 设备与虚拟 DHCP服务器一起连接在虚拟交换机 VMnet8 上，这样就实现了虚拟机联网。
> VMware Network Adapter VMnet8 虚拟网卡主要是为了实现主机与虚拟机之间的通信。

从以下两点我们可以判断 VMware Network Adapter VMnet8 虚拟网卡是正常的：
- 主机可以 ping 同虚拟机；并能够访问虚拟机的 Web 服务
- 从 ssh 登录日志（ `Last login: Mon Dec  7 12:01:57 2020 from 192.168.18.1`）可以发现是从网关登录过来的。

推测出很有可能是网关的问题：
将网络配置文件 /etc/netplan/00-installer-config.yaml 中的网关指定去除掉，发现仍然不行。
无意中把 dhcp4: true 给过来之后发现可以 ping 同外网了。神奇！！！
```diff
# This is the network config written by 'subiquity'
network:
  ethernets:
    ens33:
-     dhcp4: no
+     dhcp4: true
      addresses: [192.168.18.100/24]
      gateway4: 192.168.18.1
-     nameservers:
        addresses: [192.168.18.1,202.101.224.69,119.29.29.29]
  version: 2
```

最终的网络配置文件
```json
# This is the network config written by 'subiquity'
network:
  ethernets:
    ens33:
      dhcp4: true
      addresses: [192.168.18.100/24]
      nameservers:
        addresses: [192.168.18.1,202.101.224.69,119.29.29.29]
  version: 2
```

可以 ping 通路由器和百度
```shell
abadstring@ubuntu:~$ ping 192.168.1.1
PING 192.168.1.1 (192.168.1.1) 56(84) bytes of data.
64 bytes from 192.168.1.1: icmp_seq=1 ttl=128 time=5.89 ms
64 bytes from 192.168.1.1: icmp_seq=2 ttl=128 time=5.08 ms
64 bytes from 192.168.1.1: icmp_seq=3 ttl=128 time=2.54 ms
^C
--- 192.168.1.1 ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2003ms
rtt min/avg/max/mdev = 2.541/4.501/5.885/1.424 ms
abadstring@ubuntu:~$ ping www.baidu.com
PING www.a.shifen.com (36.152.44.95) 56(84) bytes of data.
64 bytes from 36.152.44.95 (36.152.44.95): icmp_seq=1 ttl=128 time=22.3 ms
64 bytes from 36.152.44.95 (36.152.44.95): icmp_seq=2 ttl=128 time=24.1 ms
64 bytes from 36.152.44.95 (36.152.44.95): icmp_seq=3 ttl=128 time=22.6 ms
^C
--- www.a.shifen.com ping statistics ---
3 packets transmitted, 3 received, 0% packet loss, time 2004ms
rtt min/avg/max/mdev = 22.254/23.014/24.140/0.812 ms
```

**还有最后一个问题：启用了 DHCP 那么虚拟机的 IP 地址是否会变动呢？**
没有其他办法了。没有找到任何在 NAT 模式下固定静态 IP 并还能访问外部网络的可行方法。


### 7.5.3. nmap

最后介绍以下 nmap 的用法：
> https://blog.csdn.net/keepsmi1e/article/details/9370049

用 namp 对局域网扫描一遍，然后查看 arp 缓存表就可以知道局域内 ip 对应的 mac 了。
namp 比较强大也可以直接扫描 mac 地址和端口。执行扫描之后就可以 cat /proc/net/arp 查看arp缓存表了。


进行ping扫描，打印出对扫描做出响应的主机：
`nmap -sP 192.168.1.0/24`

仅列出指定网络上的每台主机，不发送任何报文到目标主机：　
`nmap -sL 192.168.1.0/24`

探测目标主机开放的端口，可以指定一个以逗号分隔的端口列表(如-PS 22，23，25，80)：
`nmap -PS 192.168.1.234`

使用UDP ping探测主机：
`nmap -PU 192.168.1.0/24`

使用频率最高的扫描选项（SYN扫描,又称为半开放扫描），它不打开一个完全的TCP连接，执行得很快：　
`nmap -sS 192.168.1.0/24`

## 7.6. 文件上传
上传本地文件到服务器
```shell
scp [本地文件] [服务器用户名]@[服务器IP]:[服务器路径]
scp ./HotelManagementSystem.sql abadstring@192.168.1.105:/home/abadstring/
```

## 7.7. 常见问题
```shell
# 安装中文字体
apt-get install ttf-arphic-uming 
apt-get install xfonts-intl-chinese
apt-get install xfonts-wqy

# 安装32位库
sudo apt-get install lib32bz2-1.0

# gcc安装环境没有安装完善
sudo apt-get install gcc-multilib

# 把用户whoami加入组vboxf中
sudo adduser whoami vboxsf

#  安装大多数音视频解码器
sudo apt-get install ubuntu-restricted-extras
```


# 8. CMD

查看WiFi密码
for /f "skip=9 tokens=1,2 delims=:" %i in ('netsh wlan show profiles') do  @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear

ipconfig /displaydns      //显示本机上的DNS域名解析列表
ipconfig /flushdns        //删除本机上的DNS域名解析列表

查看指定端口的占用情况
netstat -aon|findstr "9050"

attrib G:\"*" -s -h -r /s /d

磁盘清理
cleanmgr

电源效率诊断报告
powercfg /energy

关机
shutdown     shutdown.exe

DirectX 诊断工具 - 系统和各硬件的信息
dxdiag

软件信息
systeminfo

星球大战
telnet towel.blinkenlights.nl

磁盘检查
chkdsk

explorer－－－－－－－打开资源管理器
logoff－－－－－－－－注销命令
tsshutdn－－－－－－－60秒倒计时关机命令
lusrmgr.msc－－－－－ 本机用户和组
services.msc－－－－－本地服务设置
oobe/msoobe /a－－－－检查XP是否激活
notepad－－－－－－－－打开记事本
cleanmgr－－－－－－－**整理
net start messenger－－－－开始信使服务
net stop messenger－－－－－停止信使服务
compmgmt.msc－－－－－计算机管理
conf－－－－－－－－－－－启动 netmeeting
dvdplay－－－－－－－－DVD播放器
charmap－－－－－－－－启动字符映射表
diskmgmt.msc－－－－磁盘管理实用程序
calc－－－－－－－－－－－启动计算器
dfrg.msc－－－－－－－磁盘碎片整理程序
chkdsk.exe－－－－－Chkdsk磁盘检查
devmgmt.msc－－－ 设备管理器
regsvr32 /u *.dll－－－－停止dll文件运行
drwtsn32－－－－－－ 系统医生
rononce －p －－－－15秒关机
dxdiag－－－－－－－－－检查DirectX信息
regedt32－－－－－－－注册表编辑器
Msconfig.exe－－－系统配置实用程序
rsop.msc－－－－－－－组策略结果集
mem.exe－－－－－－－－显示内存使用情况
regedit.exe－－－－注册表
winchat－－－－－－－－XP自带局域网聊天
progman－－－－－－－－程序管理器
winmsd－－－－－－－－－系统信息
perfmon.msc－－－－计算机性能监测程序
winver－－－－－－－－－检查Windows版本
sfc /scannow－－－－－扫描错误并复原
taskmgr－－－－－任务管理器（2000／xp／2003）
wmimgmt.msc－－－－打开windows管理体系结构(WMI)
wupdmgr－－－－－－－－windows更新程序
w脚本－－－－－－－－windows脚本宿主设置
write－－－－－－－－－－写字板
winmsd－－－－－－－－－系统信息
wiaacmgr－－－－－－－扫描仪和照相机向导
mem.exe－－－－－－－－显示内存使用情况
Msconfig.exe－－－系统配置实用程序
mplayer2－－－－－－－简易widnows media player
mspaint－－－－－－－－画图板
mstsc－－－－－－－－－－远程桌面连接
mplayer2－－－－－－－媒体播放机
magnify－－－－－－－－放大镜实用程序
mmc－－－－－－－－－－－－打开控制台
mobsync－－－－－－－－同步命令
dcomcnfg－－－－－－－打开系统组件服务
ddeshare－－－－－－－打开DDE共享设置
dvdplay－－－－－－－－DVD播放器
net stop messenger－－－－－停止信使服务
net start messenger－－－－开始信使服务
notepad－－－－－－－－打开记事本
nslookup－－－－－－－网络管理的工具向导
ntbackup－－－－－－－系统备份和还原
narrator－－－－－－－屏幕“讲述人”
ntmsmgr.msc－－－－移动存储管理器
ntmsoprq.msc－－－移动存储管理员*作请求
netstat －an－－－－(TC)命令检查接口
syncapp－－－－－－－－创建一个公文包
sysedit－－－－－－－－系统配置编辑器
sigverif－－－－－－－文件签名验证程序
sndrec32－－－－－－－录音机
shrpubw－－－－－－－－创建共享文件夹
secpol.msc－－－－－本地安全策略
syskey－－－－－－－－－系统加密，一旦加密就不能解开，保护windows xp系统的双重密码
services.msc－－－本地服务设置
Sndvol32－－－－－－－音量控制程序
sfc.exe－－－－－－－－系统文件检查器
sfc /scannow－－－windows文件保护
tsshutdn－－－－－－－60秒倒计时关机命令
tourstart－－－－－－xp简介（安装完成后出现的漫游xp程序）
taskmgr－－－－－－－－任务管理器
eventvwr－－－－－－－事件查看器
eudcedit－－－－－－－造字程序
explorer－－－－－－－打开资源管理器
packager－－－－－－－对象包装程序
perfmon.msc－－－－计算机性能监测程序
progman－－－－－－－－程序管理器
regedit.exe－－－－注册表
rsop.msc－－－－－－－组策略结果集
regedt32－－－－－－－注册表编辑器
rononce －p －－－－15秒关机
regsvr32 /u *.dll－－－－停止dll文件运行
regsvr32 /u zipfldr.dll－－－－－－取消ZIP支持
cmd.exe－－－－－－－－cmd命令提示符
chkdsk.exe－－－－－Chkdsk磁盘检查
certmgr.msc－－－－证书管理实用程序
calc－－－－－－－－－－－启动计算器
charmap－－－－－－－－启动字符映射表
cliconfg－－－－－－－SQL SERVER 客户端网络实用程序
Clipbrd－－－－－－－－剪贴板查看器
conf－－－－－－－－－－－启动netmeeting
cleanmgr－－－－－－－**整理
ciadv.msc－－－－－－索引服务程序
osk－－－－－－－－－－－－打开屏幕键盘
iexpress－－－－－－－木马捆绑工具，系统自带
fsmgmt.msc－－－－－共享文件夹管理器
utilman－－－－－－－－辅助工具管理器
gpedit.msc－－－－－组策略

ipconfig /displaydns      //显示本机上的DNS域名解析列表
ipconfig /flushdns        //删除本机上的DNS域名解析列表


## 8.1. 批处理清理VS工程目录（递归删除Debug, Release, ipch目录及*.sdf文件）
```bat
@echo off
setlocal enabledelayedexpansion  

for /r . %%a in (Debug) do (  
  if exist %%a (
  echo "delete" %%a
  rd /s /q "%%a" 
 )
)

for /r . %%a in (Release) do (  
  if exist %%a (
  echo "delete" %%a
  rd /s /q "%%a" 
 )
)

for /r . %%a in (ipch) do (  
  if exist %%a (
  echo "delete" %%a
  rd /s /q "%%a" 
 )
)

for /r . %%a in (*.sdf) do (  
  if exist %%a (
  echo "delete" %%a
  del "%%a" 
 )
)

for /r . %%a in (*.db) do (  
  if exist %%a (
  echo "delete" %%a
  del "%%a" 
 )
)

pause
```


# 9. Markdown
Markdown 常用语法：
```markdown
Markdown 目录：
[TOC]

Markdown 标题：
# 这是 H1
## 这是 H2
### 这是 H3

Markdown 列表：
- 列表项目
1. 列表项目

*斜体*或_斜体_
**粗体**
***加粗斜体***
~~删除线~~

Markdown 插入链接：
[链接文字](链接网址 "标题")

Markdown 插入图片：
![alt text](/path/to/img.jpg "Title")

Markdown 插入代码块：
    ```python
    #!/usr/bin/python3
    print("Hello, World!");
    ```

Markdown 引用：
> 引用内容

Markdown 分割线：
---

Markdown 换行：
<br>

Markdown 段首缩进：
&ensp; or &#8194; 表示一个半角的空格
&emsp; or &#8195;  表示一个全角的空格
&emsp;&emsp; 两个全角的空格（用的比较多）
&nbsp; or &#160; 不断行的空白格
```


# 10. 基于项目的文件夹分类与命名规范
> [一次整理终生轻松的文件整理术](https://zhuanlan.zhihu.com/p/31436258)
```
.
├─01_项目名称_开始时间_结束时间
│  ├─01_阶段名称_开始时间_结束时间
│  │  └─01_文件名_版本号_时间戳.文件后缀
│  └─02_阶段名称_开始时间_结束时间
└─02_毕设Markdown解析器_20210101_20210531
    ├─00_导师选择_20210101_20210104
    ├─01_开题报告_20210105_20210110
    ├─02_需求分析_20210111_20210131
    ├─03_项目实现_20210201_20210331
    ├─04_毕业论文_20210401_20210430
    │  ├─01_ref_电商用户行为数据分析系统的设计与实现_来自学长毕设.pdf
    │  ├─02_ref_基于hadoop大数据框架的个性化推荐系统研究与实现_邓玉林.caj
    │  ├─11_基于语法树和Diff算法的Markdown解析器的设计与实现_V0.1_20210403.tex
    │  ├─11_基于语法树和Diff算法的Markdown解析器的设计与实现_V0.2_20210410_aBadString.tex
    │  ├─11_基于语法树和Diff算法的Markdown解析器的设计与实现_V1.0_20210415.tex
    │  ├─11_基于语法树和Diff算法的Markdown解析器的设计与实现_V1.1_20210420_还差支持数学公式.tex
    │  ├─11_doing_基于语法树和Diff算法的Markdown解析器的设计与实现_V1.2.tex
    │  ├─21_Diff算法设计与实现_V1.0_20210405.md
    │  └─31_out_基于语法树和Diff算法的Markdown解析器的设计与实现_V2.0_20210426.tex
    └─05_毕业答辩_20210501_20210531
```

- 文件夹分类：
  - 以项目为单位，分出一级文件夹。命名：序号_项目名称_开始时间_结束时间
  - 以项目的各个阶段，分出二级文件夹。命名：序号_阶段名称_开始时间_结束时间
- 文件命名：序号_文件名_版本号_时间戳.文件后缀
  - 命名不要有空格和特殊字符，不同部分以下划线分隔。如果实在需要允许使用中文全角字符。
  - 版本号使用大写 V 开始，使用两位版本号(主版本号和辅版本号)。第一个完整的版本为 1.0，在此之前为 0.X。每次修改辅版本号增加，每次提交评审主版本号增加。
  - 如果需要可以在文件名末尾增加作者和简略备注
- 序号使用两位十进制数字表示，以 01 开始。
    - 第一位数字以 0 开始；第二位数字以 1 开始，0 保留。
    - 如果序号只作为固定排序的用途，那么首位仅为 0 即可，即以 0X 的形式标出序号
    - 序号的特殊含义：
      - 0X_ref_ 表示收集到的原始材料，可在后面注明来源；
      - 1X_ 表示由原始材料修改或者自己从零开始的产出；
      - 1X_doing_ 表示正在做的尚未完成的；
      - 2X_ (也可写作 2X_temp_ ) 是工作过程中的副产物或者临时数据；
      - 3X_ (也可写作 3X_out_ ) 是最终输出的产物（要提交的）。


# 11. 正则表达式

正则表达式在线测试工具：https://regex101.com/

## 11.1. 限定符

a*：a 出现 0 次或多次
a+：a 出现 1 次或多次
a?：a 出现 0 次或 1 次
a{6}：a 出现 6 次
a{2,6}：a 出现 2 到 6 (2,3,4,5,6) 次
a{2,}：a 出现 2 次及以上

(ab)*：ab 出现 0 次或多次

## 11.2. 或运算符

(a|b)：匹配 a 或者 b
((ab)|(cd))：匹配 ab 或者 cd

## 11.3. 字符集合

[abc]：匹配 a 或者 b 或者 c（集合 abc 中的任意一个）
[a-z]：匹配 a 到 z 的字符集合
[^0-9]：匹配不是集合 0 到 9的
[a-fA-F0-9]：匹配 a到f A到F 0到9 的集合（十六进制的数字）

## 11.4. 元字符

\d：匹配数字字符
\D：匹配非数字字符
\w：匹配单词字符（英文大小写字母、数字、下划线）
\W：匹配非单词字符
\s：匹配空白字符（空格、换行、回车）
\S：匹配非空白字符
.：匹配除换行符以外的任意字符
\b：标注字符边界
^：匹配行首
$：匹配行尾

正则表达式模式是贪婪模式，尽可能多的匹配字符。加上 ? 使它变为懒惰模式。

- <.+> 匹配：`<span><b>hello,regular</b></span>`
- <.+?> 匹配：`<span>`、`<b>`、`</b>`、`</span>`

## 11.5. 实例

1. **快速选择 git meager**
```
=======(.|\r|\n)*?>>>>>>> ef18e3b4337f758c1cde2fee14d0251238b399a1
```
- (.|\r|\n)：匹配所有字符和换行符
- (.|\r|\n)*?：懒惰模式
可以匹配如下文本：
```
=======

class A {

}

class B {

}

>>>>>>> ef18e3b4337f758c1cde2fee14d0251238b399a1
```

2. **十六进制 RGB 颜色值匹配**
```
#[a-fA-F0-9]{6}\b
```
```
#00
#ffffff
#fafafa
#00hh00
#000000
#ffffffff
```

3. **IP 地址匹配**
```
\b(((25[0-5])|(2[0-4]\d)|([01]?\d\d?))\.){3}((25[0-5])|(2[0-4]\d)|([01]?\d\d?))\b
```
说明
- (25[0-5])|(2[0-4]\d)|([01]?\d\d?)
    - (25[0-5])：匹配 250 到 255
    - (2[0-4]\d)：匹配 200 到 249
    - ([01]?\d\d?)：匹配
        - [01]\d\d：匹配 000 到 199
        - \d\d：匹配 00 到 99
        - ~~[01]\d：匹配 00 到 19~~
        - \d：匹配 0 到 9
```
123
255.255.255.0
192.168.0.1
0.0.0.0
256.1.1.1
This is not IP address.
123.123.0
```